using UnityEngine;
using System.Collections;
using UnityEditor;
using System.Collections.Generic;
using System;
using UnityEngine.SceneManagement;

/// <summary>
/// The Scenario class is used to generate a battle map with an objective for the Player to meet. 
/// </summary>
public class Scenario : MonoBehaviour {
    //Constants
    /// <summary>
    /// Constants:
    /// static string PLAYER_STATS_FILE - File from which to draw Character stats.
    /// static string MONSTER_STATS_FILE - File from which to draw Monster Stats.
    /// 
    /// Variables:
    /// Tile_Grid tile_grid  - The tile_grid object that contains the array of Tile Objects that acts as the map for the Scenario.
	/// Game_Controller controller - The Game Controller Object in charge of overarching game processes.
    /// string scenario_file - The file from which the Scenario reads in its values.
    /// int scenario_id - The ID used to separate this Scenario from others. Also used for Scenario selection from the available_scenarios list.
    /// string scenario_sector - The sector the Scenario can appear in. Not in use yet.
    /// string scenario_name - The Name of the Scenario.
    /// string description - The descrition for the Scenario.
    /// Scenario_Objectives objective - The Objective for the Scenario. Defined how to win the Scenario.
    /// List<string> rewards - The Rewards for completing the Scenario's Objective.
    /// string bonus_objective - The Bonus Objective for the Scenario. Defines how to earn the Bonus Rewards for the Scenario.
    /// List<string> bonus_rewards - The Rewards for completing the Scenario's Bonus Objective.
    /// List<int> unlocks_scenarios - Scenarios that will be added to the available_scenarios List regardless of outcome.
    /// List<int> unlocks_scenarios_on_loss - Scenarios that will be added to the available_scenarios List if the Player does not achieve the Objective.
    /// List<int> unlocks_scenarios_on_win - Scenarios that will be added to the available_scenarios List if the Player achieves the Objective.
    /// List<int> unlocks_scenarios_on_bonus - Scenarios that will be added to the available_scenarios List if the Player achieves the Bonus Objective. 
    /// GameObject curr_player - The Character that is currently Acting.
    /// GameObject cursor - The Cursor Object is used to select Tiles and Characters for Actions. It shows which Tile Object the player's mouse is over.
    /// List<GameObject> cursors - The List of currently active Cursor Objects. Multiple Cursors are necessary because of AoE Actions.
    /// String cursor_name - Stores the current Character's Action so we can tell if we need to change the number of Cursor Objects in the cursors List.
    /// int curr_character_num - The index for the current character in the characters Array.
    /// ArrayList characters - The list of all currently Active Characters in the scenario.
    /// List<> tile_objects - The list of all Objects currently Active in the scenario.
    /// List<Tile_Effect> tile_effects - The list of all Tile_effects. USed to decrement their timers at the end of a round.
    /// Character_Script[] player_character_data - The Array of Character scripts holding data for all available player Characters. 
    ///     Generated by the PLAYER_STATS_FILE.
    /// Character_Script[] monster_character_data - The Array of Character scripts holding data for all available monster Characters. 
    ///     Generated by the MONSTER_STATS_FILE.
    /// List<GameObject> turn_order - The List of Characters sorted by Dexterity to determine turn order.
    /// Transform clicked_tile - The Tile object curretly Clicked by the Player.
    /// Transform selected_tile - The Tile object currently Selected by the Player. Also where the main cursor Object should be.
    /// List<Transform> reachable_tiles - The List of tiles that are reachable for the current Character's current Action.
    /// List<GameObject> reachable_tile_objects - The List of Objects used to mark what Tiles are Reachable.
    /// int curr_round - The number of the current round. Not currently in Use.
    /// </summary>
    private static string PLAYER_STATS_FILE = "Assets/Resources/Characters/Player_Characters/Player_Character_Data.txt";
    private static string MONSTER_STATS_FILE = "Assets/Resources/Characters/Monster_Characters/Monster_Character_Data.txt";

    public Tile_Grid tile_grid { get; private set; }
	public Game_Controller controller { get; private set; }
    public string scenario_file { get; private set; }
    public int scenario_id { get; private set; }
    public string scenario_sector { get; private set; }
    public string scenario_name { get; private set; }
    public string description { get; private set; }
    public Scenario_Objectives objective { get; private set; }
    public List<string> rewards { get; private set; }
    public string bonus_objective { get; private set; }
    public List<string> bonus_rewards { get; private set; }
    public List<int> unlocks_scenarios { get; private set; }
    public List<int> unlocks_scenarios_on_loss { get; private set; }
    public List<int> unlocks_scenarios_on_win { get; private set; }
    public List<int> unlocks_scenarios_on_bonus { get; private set; }
    public GameObject curr_player { get; private set; }
    public GameObject cursor { get; private set; }
    public List<GameObject> cursors { get; private set; }
    public String cursor_name { get; private set; }
    public int curr_character_num { get; private set; }
    public ArrayList characters { get; private set; }
    public List<GameObject> tile_objects { get; private set; }
    public List<GameObject> tile_effects { get; private set; }
    public Character_Script[] player_character_data { get; private set; }
    public Character_Script[] monster_character_data { get; private set; }
    public List<GameObject> turn_order { get; private set; }
    public Transform clicked_tile { get; set; }
    public Transform selected_tile { get; set; }
    public List<Transform> reachable_tiles { get; private set; }
    public List<GameObject> reachable_tile_objects { get; private set; }
    public int curr_round { get; private set; }

    /// <summary>
    /// Constructor for the Class. Asks for a file from which to parse its fields.
    /// </summary>
    /// <param name="filename">The file from which to get its fields.</param>
    public Scenario(string filename)
    {
        controller = Game_Controller.controller;
        scenario_file = filename;
        //Initialize Lists
        rewards = new List<string>();
        bonus_rewards = new List<string>();
        List<int> unlocks_scenarios = new List<int>();
        List<int> unlocks_scenarios_on_loss = new List<int>();
        List<int> unlocks_scenarios_on_win = new List<int>();
        List<int> unlocks_scenarios_on_bonus = new List<int>();
        //Read in the file
        string[] lines = System.IO.File.ReadAllLines(scenario_file);
        string line = "";
        string[] elements = new string[2];
        //30 is the default grid size;
        int grid_width=30;
        int grid_length=30;
        Material[] materials = new Material[10];
        double[] tile_modifiers = new double[10];
        int[,] tile_mat_ids = new int[grid_width, grid_length];
        int[,] object_sprite_ids = new int[grid_width, grid_length];
        int[,] character_ids = new int[grid_width, grid_length];
        //Read through the file line by line, looking for specific headings
        for (int i = 0; i < lines.Length; i++)
        {
            line = lines[i];
            switch (line)
            {
                //ID of the scenario
                case "[ID]":
                    scenario_name = lines[i + 1];
                    i += 2;
                    break;
                //What Sector the scenario can be found in
                case "[Sector]":
                    scenario_sector = lines[i + 1];
                    i += 2;
                    break;
                //Name of the Scenario
                case "[Name]":
                    scenario_name = lines[i + 1];
                    i+=2;
                    break;
                //Description for the Scenario
                case "[Description]":
                    description = lines[i + 1];
                    i += 2;
                    break;
                //Objective for the scenario (see Objectives enum for list of possible objectives.)
                case "[Objective]":
                    foreach (Scenario_Objectives obj in System.Enum.GetValues(typeof(Scenario_Objectives)))
                    {
                        if(obj.ToString() == lines[i + 1])
                        {
                            objective = obj;
                        }
                    }
                    i += 2;
                    break;
                //Reward for winning the scenario
                case "[Reward]":
                    for(int j = i+1; j<lines.Length; j++)
                    {
                        if (lines[j] != "")
                        {
                            rewards.Add(lines[j]);
                        }
                        else
                        {
                            i = j;
                            j = lines.Length;
                        }
                    }
                    break;
                //Bonus objective for the scenario
                case "[Bonus Objective]":
                    bonus_objective = lines[i + 1];
                    i += 2;
                    break;
                //Reward for completing the Bonus Objective
                case "[Bonus Reward]":
                    for (int j = i + 1; j < lines.Length; j++)
                    {
                        if (lines[j] != "")
                        {
                            bonus_rewards.Add(lines[j]);
                        }
                        else
                        {
                            i = j;
                            j = lines.Length;
                        }
                    }
                    break;
                //Scenario IDs that will be unlocked regardless of wether or not the Objective is met
                case "[Unlocks]":
                    elements = lines[i + 1].Split(';');
                    int id = scenario_id;
                    foreach (string s in elements)
                    {
                        if (int.TryParse(s, out id))
                        {
                            unlocks_scenarios.Add(id);
                        }
                    }
                    i += 2;
                    break;
                //Scenario IDs that will be unlocked if the Objective is not met
                case "[Unlocks on Loss]":
                    elements = lines[i + 1].Split(';');
                    id = scenario_id;
                    foreach (string s in elements)
                    {
                        if (int.TryParse(s, out id))
                        {
                            unlocks_scenarios_on_loss.Add(id);
                        }
                    }
                    i += 2;
                    break;
                //Scenario IDs that will be unlocked if the Objective is met
                case "[Unlocks on Win]":
                    elements = lines[i + 1].Split(';');
                    id = scenario_id;
                    foreach (string s in elements)
                    {
                        if (int.TryParse(s, out id))
                        {
                            unlocks_scenarios_on_win.Add(id);
                        }
                    }
                    i += 2;
                    break;
                //Scenario IDs that will be unlocked if the Bonus Objective is met
                case "[Unlocks on Bonus]":
                    elements = lines[i + 1].Split(';');
                    id = scenario_id;
                    foreach (string s in elements)
                    {
                        if (int.TryParse(s, out id))
                        {
                            unlocks_scenarios_on_bonus.Add(id);
                        }
                    }
                    i += 2;
                    break;
                //Size of the tile grid map
                case "[Grid Size]":
                    int width = 30;
                    int length = 30;
                    if (int.TryParse(lines[i + 1].Split(';')[0], out width))
                    {
                        grid_width = width;
                    }
                    if (int.TryParse(lines[i + 1].Split(';')[1], out length))
                    {
                        grid_length = length;
                    }
                    i += 2;
                    break;
                case "[Tiles]":
                    //build materials
                    materials = new Material[10];
                    for (int j = i + 1; j < i + 10 + 1; j++)
                    {
                        string[] entries = lines[j].Split(' ');
                        materials[(j-i-1)] = (Material)Resources.Load("Objects/Materials/TileMat0" + (j-i-1));
                        materials[(j - i - 1)].name = entries[1];
                        materials[(j-i-1)].mainTexture = (Texture)Resources.Load("Textures/" + entries[1]);
                        double modifier;
                        if (double.TryParse(entries[2], out modifier))
                        {
                            tile_modifiers[j - i - 1] = modifier;
                        }
                    }

                    break;
                case "[Tile Map]":
                    tile_mat_ids = new int[grid_width, grid_length];
                    for( int k = i+1; k<i+grid_length+1; k++)
                    {
                        string[] entries = lines[k].Split(';');
                        for (int l = 0; l<grid_width; l++)
                        {
                            int sprite;
                            if (int.TryParse(entries[l], out sprite))
                            {
                                tile_mat_ids[k-i-1, l] = sprite;
                            }
                        }
                    }
                    break;
                case "[Object Map]":
                    object_sprite_ids = new int[grid_width, grid_length];
                    for (int k = i + 1; k < i + grid_length+1; k++)
                    {
                        string[] entries = lines[k].Split(';');
                        for (int l = 0; l < grid_width; l++)
                        {
                            int sprite;
                            if (int.TryParse(entries[l], out sprite))
                            {
                                object_sprite_ids[k-i-1, l] = sprite;
                            }
                        }
                    }
                    break;
                case "[Character Map]":
                    character_ids = new int[grid_width, grid_length];
                    for (int k = i + 1; k < i + grid_length + 1; k++)
                    {
                        string[] entries = lines[k].Split(';');
                        for (int l = 0; l < grid_width; l++)
                        {
                            int sprite;
                            if (int.TryParse(entries[l], out sprite))
                            {
                                character_ids[k - i - 1, l] = sprite;
                            }
                        }
                    }
                    break;
                //Default in case none of the above cases are met
                default:
                    break;
            }
            //Resume new scenario creation
            tile_grid = new Tile_Grid(grid_width, grid_length, materials, tile_modifiers, tile_mat_ids, object_sprite_ids, character_ids);

            curr_round = 0;
            curr_character_num = 0;
            turn_order = new List<GameObject>();
            reachable_tiles = new List<Transform>();
            reachable_tile_objects = new List<GameObject>();
            tile_objects = new List<GameObject>();
        }
    }

    /// <summary>
    /// Function to read in Character data from a file. Returns a Character_Script array from the data within the file.
    /// </summary>
    /// <param name="file">The file from which to read in Character Scripts.</param>
    /// <returns>Character_Script Array constructed from the given file.</returns>
    Character_Script[] Read_Character_Data(string file)
    {
        string[] lines = System.IO.File.ReadAllLines(file);
        Character_Script[] objects = new Character_Script[lines.Length / 15];

        int count = 0;
        string name = "";
        int level = 1;
        int strength = 1;
        int coordination = 1;
        int spirit = 1;
        int dexterity = 1;
        int vitality = 1;
        int speed = 6;
        int canister_max = 1;
        string weapon = "Sword";
        string armor = "Light";
        string animator = "Beetleboar";
        float[] scale = new float[3];
        foreach (string line in lines)
        {
            string[] elements = line.Split(':');
            if (!elements[0].Contains("#") && elements.Length > 1)
            {
                if (elements[0] == "name")
                {
                    name = elements[1].Trim();
                }
                else if (elements[0] == "level")
                {
                    if (int.TryParse(elements[1], out level))
                    { }
                }
                else if (elements[0] == "strength")
                {
                    if (int.TryParse(elements[1], out strength))
                    { }
                }
                else if (elements[0] == "coordination")
                {
                    if (int.TryParse(elements[1], out coordination))
                    { }
                }
                else if (elements[0] == "spirit")
                {
                    if (int.TryParse(elements[1], out spirit))
                    { }
                }
                else if (elements[0] == "dexterity")
                {
                    if (int.TryParse(elements[1], out dexterity))
                    { }
                }
                else if (elements[0] == "vitality")
                {
                    if (int.TryParse(elements[1], out vitality))
                    { }
                }
                else if (elements[0] == "speed")
                {
                    if (int.TryParse(elements[1], out speed))
                    { }
                }
                else if (elements[0] == "canister_max")
                {
                    if (int.TryParse(elements[1], out canister_max))
                    { }
                }
                else if (elements[0] == "weapon")
                {
                    weapon = elements[1];
                }
                else if (elements[0] == "armor")
                {
                    armor = elements[1];
                }
                else if (elements[0] == "accessories")
                {

                }
                else if (elements[0] == "animator")
                {
                    animator = elements[1].Trim();
                }
                else if (elements[0] == "scale")
                {
                    string[] scales = elements[1].Split(',');
                    scale = new float[3];
                    int x = 0;
                    foreach (string s in scales)
                    {
                        if (float.TryParse(s.Trim(), out scale[x]))
                        { }
                        x++;
                    }
                    if(x == 1)
                    {
                        scale[1] = scale[0];
                        scale[2] = scale[0];
                    }

                }
            }
            if (elements[0] == "")
            {
                objects[count] = new Character_Script(name, level, strength, coordination, spirit, dexterity, vitality, speed, canister_max, weapon, armor, animator, scale);
                count++;
            }
        }
        return objects;
    }

    /// <summary>
    /// Function used to sort GameObjects by their Dexterity Stat. 
    /// </summary>
    /// <param name="o1">The first Object to Compare</param>
    /// <param name="o2">The second Object to Compare</param>
    /// <returns>1 if the first Object's Dexterity is greater, 0 if they are equal, -1 if the second Object's Dexterity is greater. </returns>
    public static int Sort_By_Dex(GameObject o1, GameObject o2)
    {
        if (o1.GetComponent<Character_Script>().dexterity > o2.GetComponent<Character_Script>().dexterity)
        {
            return 1;
        }
        else if (o1.GetComponent<Character_Script>().dexterity < o2.GetComponent<Character_Script>().dexterity)
        {
            return -1;
        }
        else
        {
            return 0;
        }
    }

    /// <summary>
    /// Function to Instantiate all of the relevant Scenario Tiles, Objects and Characters. Basically the Start method.
    /// </summary>
    public void Load_Scenario()
    {
        //Instantiate the actual tile objects
        tile_grid.Instantiate();

        //Load player and monster stats and come up with turn order
        player_character_data = Read_Character_Data(PLAYER_STATS_FILE);
        monster_character_data = Read_Character_Data(MONSTER_STATS_FILE);
        Character_Script[] character_data;
        int char_num = 0;
        characters = new ArrayList();

        cursor = GameObject.FindGameObjectWithTag("Cursor");
        cursors = new List<GameObject>();
        GameObject[] objects = GameObject.FindGameObjectsWithTag("Character (Friend)");

        tile_effects = new List<GameObject>();
        if (GameObject.FindGameObjectWithTag("Tile Effect"))
        {
            foreach (GameObject obj in GameObject.FindGameObjectsWithTag("Tile Effects"))
            {
                tile_effects.Add(obj);
            }
        }

        //set starting positions for players
        //TODO change this to read positions from the scenario file.
        foreach (GameObject game_object in objects)
        {
            characters.Add(game_object);

            //Get the character ID from the tile grid
            int char_id = game_object.GetComponent<Character_Script>().character_id;

            Character_Script char_data;
            if (char_id / 10000 == 1)
            {
                //Player
                char_data = player_character_data[char_id % 100 - 1];
                game_object.tag = "Character (Friend)";
            }
            else if (char_id / 10000 == 2 )
            {
                //Monster
                char_data = monster_character_data[char_id % 100 -1];
                game_object.tag = "Character (Enemy)";
            }
            else
            {
                char_data = monster_character_data[0];
            }
            game_object.GetComponent<Character_Script>().Instantiate(char_data, char_id, char_num, char_id/1000%10);
            turn_order.Add(game_object);
            char_num++;
        }

        //Get Objects
        objects = GameObject.FindGameObjectsWithTag("Object");
        foreach (GameObject game_object in objects)
        {
            tile_objects.Add(game_object);
        }

        turn_order.Sort(Sort_By_Dex);
        curr_character_num = characters.Count - 1;
        curr_player = turn_order[curr_character_num];
        curr_player.GetComponent<Animator>().SetBool("Selected", true);
        char_num = 0;
        curr_player.GetComponent<Character_Script>().Find_Action("Move").Select(curr_player.GetComponent<Character_Script>());
        //GetComponent<Character_Script>().state = Character_Script.States.Moving;
        //FindReachable(curr_player.GetComponent<Character_Script>().action_curr, curr_player.GetComponent<Character_Script>().SPEED);
        //MarkReachable();


        //set initial values for selected and clicked tiles.
        selected_tile = tile_grid.tiles[0, 0];
        clicked_tile = tile_grid.tiles[0, 0];
    }

    /// <summary>
    /// Function to remove all relevant Scenario Tiles, Objects and Characters. Used for cleaning up and switching between scenarios.
    /// </summary>
    public void Unload_Scenario()
    {
        //destroy the old map
        GameObject[] objects = GameObject.FindGameObjectsWithTag("Tile");
        foreach (GameObject game_object in objects)
        {
            Destroy(game_object);
        }
        objects = GameObject.FindGameObjectsWithTag("Object");
        foreach (GameObject game_object in objects)
        {
            Destroy(game_object);
        }

    }

    /// <summary>
    /// Creates a Tile_Effect to restore Mana at a Random tile.
    /// </summary>
    public void Spawn_Mana_Orb()
    {
        bool spawned = false;
        string[] value = { "MPC", "5" };
        
        while (!spawned)
        {
            int random_x = (int)(UnityEngine.Random.value * 100) % tile_grid.tiles.GetLength(0);
            int random_y = (int)(UnityEngine.Random.value * 100) % tile_grid.tiles.GetLength(1);
            GameObject obj = tile_grid.tiles[random_x, random_y].gameObject;
            Tile tile = obj.GetComponent<Tile>();
            if (tile.effect == null && tile.obj == null && tile.traversible)
            {
                Debug.Log("Spawned manawell at: " + random_x + "," + random_y );
                Tile_Effect effect = new Tile_Effect("Manawell", "Heal", 10, value, 1, obj);
                effect.Instantiate();
                spawned = true;
            }
        }
    }

    /// <summary>
    /// Use this for initialization
    /// </summary>
    void Start () {
        controller = Game_Controller.controller;
	}

    /// <summary>
    /// Function to check if the scenario's victory condition has been met. Called every Update. 
    /// </summary>
    public void Check_For_Victory()
    {
        bool victory = true;

        //The Goal for Vanquish is to kill all Enemies on the board.
        if (objective == Scenario_Objectives.Vanquish)
        {

            foreach (GameObject character in characters)
            {
                if (character != null && character.tag != "Player")
                {
                    victory = false;
                }
            }
        }
        if (victory)
        {
            Debug.Log("CONGRATULATIONS! YOU WON!!!");
        }
    }

    /// <summary>
    /// Function to update the Cursor Object to match the current Character's current Action's Area of Effect. 
    /// </summary>
    /// <param name="selected_tile">The tile on which the Cursor Object is currently.</param>
    public void Update_Cursor(Transform selected_tile)
    {
        if (curr_player.GetComponent<Character_Script>().curr_action != null)
        {
            int area_width = curr_player.GetComponent<Character_Script>().curr_action.area.GetLength(0);
            int area_length = curr_player.GetComponent<Character_Script>().curr_action.area.GetLength(1);

            //Update cursor type to match current Ability
            if (cursor_name != curr_player.GetComponent<Character_Script>().curr_action.name)
            {
                
                //Destroy existing cursors
                foreach (GameObject game_object in cursors)
                {
                    //reachable_tile_objects.Remove(game_object);
                    Destroy(game_object);
                }
                cursors = new List<GameObject>();
                cursor_name = curr_player.GetComponent<Character_Script>().curr_action.name;

                //Recreate cursors based on type
                for (int x = 0; x < area_width; x++)
                {
                    for (int y = 0; y < area_length; y++)
                    {
                        if (curr_player.GetComponent<Character_Script>().curr_action.area[x,y] != 0)
                        {
                            GameObject instance = Instantiate(cursor);
                            if (curr_player.GetComponent<Character_Script>().curr_action.area[x, y] > 0 && 
                                curr_player.GetComponent<Character_Script>().curr_action.area[x, y] < .25f)
                            {
                                instance.GetComponent<Renderer>().material = (Material)Resources.Load("Objects/Materials/GoldMat");
                            }
                            if (curr_player.GetComponent<Character_Script>().curr_action.area[x, y] >= .25f &&
                                curr_player.GetComponent<Character_Script>().curr_action.area[x, y] < .5f)
                            {
                                instance.GetComponent<Renderer>().material = (Material)Resources.Load("Objects/Materials/GoldMat");
                            }
                            if (curr_player.GetComponent<Character_Script>().curr_action.area[x, y] >= .5f &&
                                curr_player.GetComponent<Character_Script>().curr_action.area[x, y] < .75f)
                            {
                                instance.GetComponent<Renderer>().material = (Material)Resources.Load("Objects/Materials/OrangeMat");
                            }
                            if (curr_player.GetComponent<Character_Script>().curr_action.area[x, y] > .75f)
                            {
                                instance.GetComponent<Renderer>().material = (Material)Resources.Load("Objects/Materials/RedMat");
                            }
                            cursors.Add(instance);
                        }
                    }
                }
            }

            //Update cursor positions
            if (curr_player.GetComponent<Character_Script>().curr_action == null ||
                curr_player.GetComponent<Character_Script>().curr_action.area.Length == 1)
            {
                cursors[0].transform.position = new Vector3(
                    selected_tile.position.x, 
                    selected_tile.position.y + 0.025f + Tile_Grid.TILE_SCALE * selected_tile.GetComponent<Tile>().height, 
                    selected_tile.position.z);
            }
            else if (curr_player.GetComponent<Character_Script>().curr_action.area.Length > 1)
            {
                int startX = 0;
                int startY = 0;
                if (curr_player.GetComponent<Character_Script>().curr_action.center == "Target")
                {
                    startX = selected_tile.GetComponent<Tile>().index[0];
                    startY = selected_tile.GetComponent<Tile>().index[1];
                }
                else if (curr_player.GetComponent<Character_Script>().curr_action.center == "Self")
                {
                    startX = curr_player.GetComponent<Character_Script>().curr_tile.GetComponent<Tile>().index[0];
                    startY = curr_player.GetComponent<Character_Script>().curr_tile.GetComponent<Tile>().index[1];
                }
                startX -= area_width / 2;
                startY -= area_length / 2;
                int curs_index = 0;
                for ( int x = 0; x< area_width; x++)
                {
                    for (int y = 0; y < area_length; y++)
                    {
                        if (curr_player.GetComponent<Character_Script>().curr_action.area[x, y] != 0)
                        {
                            Transform tile = tile_grid.getTile(startX + x, startY + y);
                            if (tile != null)
                            {
                                cursors[curs_index].transform.position = new Vector3(
                                    tile.position.x, 
                                    tile.position.y + 0.025f + Tile_Grid.TILE_SCALE * tile.GetComponent<Tile>().height, 
                                    tile.position.z);
                                curs_index++;
                            }
                            else
                            {
                                cursors[curs_index].transform.position = new Vector3(-10, -10, -10);
                                curs_index++;
                            }
                        }
                    }
                }

            }
            else
            {
                cursors[0].transform.position = new Vector3(
                    selected_tile.position.x, 
                    selected_tile.position.y + 0.025f + Tile_Grid.TILE_SCALE * selected_tile.GetComponent<Tile>().height, 
                    selected_tile.position.z);
            }
        }
    }

	/// <summary>
    /// Called once per frame to:
    ///     Check for victory.
    ///     Update all Characters.
    ///     Delete Objects that need to be removed.
    /// </summary>
	public void Update () {
        if (scenario_id == controller.curr_scenario.scenario_id)
        {
            //if we are on this scenario and the current player has been assigned (scenario is active)
            if (curr_player != null)
            {
                Check_For_Victory();
            }

            //update all characters
            foreach (GameObject character in characters)
            {
                character.GetComponent<Character_Script>().Update();
            }

            //Remove Tile Objects that hae to be deleted.
            GameObject[] objects = GameObject.FindGameObjectsWithTag("Delete");
            for (int i =0; i< objects.Length; i++)
            {
                if (objects[i].GetComponent<Tile_Effect>())
                {
                    tile_effects.Remove(objects[i]);
                }
                Destroy(objects[i]);
            }

            /*foreach (GameObject obj in tile_objects)
            {
                obj.GetComponent<Object_Script>().Update();
            }*/
        }         
    }

    /// <summary>
    /// Function to find all tiles within a certain distance and/or travel cost to the current player. 
    /// Adds tiles to the reachable_tiles List if they are reachable. 
    /// </summary>
    /// <param name="cost_limit">The limit in cost for traversal. </param>
    /// <param name="distance_limit">The limit in distance (number of tiles away) for traversal. </param>
    public void Find_Reachable(int cost_limit, int distance_limit)
    {
        //Debug.Log("cost limit: " + cost_limit + "; distance limit: " + distance_limit);
        tile_grid.navmesh.bfs(curr_player.GetComponent<Character_Script>().curr_tile.GetComponent<Tile>(), cost_limit, distance_limit);

        reachable_tiles = new List<Transform>();
        int x_index = curr_player.GetComponent<Character_Script>().curr_tile.GetComponent<Tile>().index[0];
        int y_index = curr_player.GetComponent<Character_Script>().curr_tile.GetComponent<Tile>().index[1];
        int i = -distance_limit;
        int j = -distance_limit;
        while (i <= distance_limit)
        {
            while (j <= distance_limit)
            {
                if (x_index + i >= 0 && x_index + i < tile_grid.grid_width)
                {
                    if (y_index + j >= 0 && y_index + j < tile_grid.grid_length)
                    {
                        int h = tile_grid.getTile(x_index + i, y_index + j).GetComponent<Tile>().height - 1;
                        if (curr_player.GetComponent<Character_Script>().state == Character_States.Moving)
                        {
                            //if (grid.GetComponent<Scenario>().tile_grid.getTile(x_index + i, y_index + j).GetComponent<Tile>().traversible){
                            //    if ((Math.Abs(x_index - (x_index + i)) * (int)(armor.weight + weapon.weight) + Math.Abs(y_index - (y_index + j)) * (int)(armor.weight + weapon.weight) + (grid.GetComponent<Scenario>().tile_grid.getTile(x_index + i, y_index + j).GetComponent<Tile>().tile_height - curr_tile.GetComponent<Tile>().tile_height) * 2) < action_curr)
                            //    {
                            //        reachable_tiles.Add(grid.GetComponent<Scenario>().tile_grid.getTile(x_index + i, y_index + j));
                            //    }
                            //}
                            if (tile_grid.getTile(x_index + i, y_index + j).GetComponent<Tile>().weight <= curr_player.GetComponent<Character_Script>().speed &&
                                tile_grid.getTile(x_index + i, y_index + j).GetComponent<Tile>().weight > 0 &&
                                tile_grid.getTile(x_index + i, y_index + j).GetComponent<Tile>().distance <= distance_limit)
                            {
                                reachable_tiles.Add(tile_grid.getTile(x_index + i, y_index + j));
                            }
                        }
                        if (curr_player.GetComponent<Character_Script>().state == Character_States.Blinking)
                        {
                            if (tile_grid.getTile(x_index + i, y_index + j).GetComponent<Tile>().traversible)
                            {
                                if ((Math.Abs(x_index - (x_index + i)) + Math.Abs(y_index - (y_index + j))) < curr_player.GetComponent<Character_Script>().speed)
                                {
                                    reachable_tiles.Add(tile_grid.getTile(x_index + i, y_index + j));
                                }
                            }
                        }
                        if (curr_player.GetComponent<Character_Script>().state == Character_States.Attacking)
                        {
                            //print ("scanned x index: " + x_index + i )
                            //Prevent Self-Harm
                            if (i != 0 || j != 0)
                            {
                                if (Math.Abs(i) + Math.Abs(j) <= distance_limit)
                                {
                                    reachable_tiles.Add(tile_grid.getTile(x_index + i, y_index + j));
                                }
                            }
                        }
                    }
                }
                j += 1;
            }
            j = -distance_limit;
            i += 1;
        }
    }

    /// <summary>
    /// Empties the reachable_tiles array. Used when a character changes Action or their turn ends.
    /// </summary>
    public void Reset_Reachable()
    {
        foreach (Transform t in reachable_tiles)
        {
            t.GetComponent<Tile>().weight = -1;
            t.GetComponent<Tile>().parent = null;
        }
        reachable_tiles = new List<Transform>();
        Clean_Reachable();
    }

    /// <summary>
    /// Marks all Tiles in the reachable_tiles array with a reachable_tile_prefab object to show that it can be reached by the current Action.
    /// </summary>
    public void Mark_Reachable()
    {
        reachable_tile_objects = new List<GameObject>();
        foreach (Transform tile in reachable_tiles)
        {
            //tile_grid.reachable_prefab.GetComponent<SpriteRenderer>().sortingOrder = tile.GetComponent<SpriteRenderer>().sortingOrder;
            if (curr_player.GetComponent<Character_Script>().state == Character_States.Moving || curr_player.GetComponent<Character_Script>().state == Character_States.Blinking)
            {
                //Set Material to blue
                //Debug.Log(tile_grid.reachable_prefab.GetComponent<Material>().name);
                tile_grid.reachable_prefab.GetComponent<Renderer>().sharedMaterial.color = new Color(0, 0, 255);
            }
            if (curr_player.GetComponent<Character_Script>().state == Character_States.Attacking)
            {
                //set material to red.
                //tile_grid.reachable_prefab.GetComponent<Renderer>().sharedMaterial.color = new Color(0, 255, 0);
            }
            reachable_tile_objects.Add((GameObject)Instantiate(tile_grid.reachable_prefab, new Vector3(tile.position.x,
                                                           //tile.position.y+0.08f,
                                                           //(float)(tile.position.y + (tile.GetComponent<SpriteRenderer>().sprite.rect.height) / 100) - .24f,
                                                           tile.position.y+.015f+ Tile_Grid.TILE_SCALE * tile.GetComponent<Tile>().height,
                                                           tile.position.z),
                                                           Quaternion.identity));

            //+ tile.GetComponent<SpriteRenderer>().sprite.rect.width/200
            // + selected_tile.GetComponent<SpriteRenderer>().sprite.rect.height/200
        }

    }

    /// <summary>
    /// Removes all reachable_tile_prefab Objects from the board. Removes the effects of MarkReachable().
    /// </summary>
    public void Clean_Reachable()
    {
        //GameObject[] objects = GameObject.FindGameObjectsWithTag("Reachable");
        foreach (GameObject game_object in reachable_tile_objects)
        {
            //reachable_tile_objects.Remove(game_object);
            Destroy(game_object);
        }
        reachable_tile_objects = new List<GameObject>();
    }

    /// <summary>
    /// Move the curr_player to the next available player in the turn_order. Turn_order is sorted in order of Dexterity.
    /// </summary>
    public void Next_Player()
    {
        foreach (GameObject chara in characters) {
            chara.GetComponent<Character_Script>().Reset_Combo_Mod();
        }

        Progress_Effects();

        if (curr_character_num % 2 == 0)
        {
            Spawn_Mana_Orb();
            Spawn_Mana_Orb();
        }

        curr_character_num = curr_character_num - 1;
        if (curr_character_num < 0)
        {
            Next_Round();
            curr_character_num = characters.Count - 1;
        }
        if (curr_character_num > characters.Count - 1)
        {
            curr_character_num = characters.Count - 1;
        }
        curr_player.GetComponent<Animator>().SetBool("Selected", false);
        curr_player = turn_order[curr_character_num];
        if (curr_player.GetComponent<Character_Script>().state == Character_States.Dead)
        {
            Next_Player();
        }
        else
        {
            curr_player.GetComponent<Animator>().SetBool("Selected", true);
        }
        //curr_player.GetComponent<Character_Script>().state = Character_Script.States.Moving;
        //FindReachable(curr_player.GetComponent<Character_Script>().action_curr, curr_player.GetComponent<Character_Script>().SPEED);

        Clean_Reachable();

        //Start new player's turn
        curr_player.GetComponent<Character_Script>().Start_Turn();
    }

    /// <summary>
    /// Move the curr_player to the previous available character in the turn_order. Turn_order is sorted in order of Dexterity.
    /// </summary>
    public void Prev_Player()
    {
        foreach (GameObject chara in characters)
        {
            chara.GetComponent<Character_Script>().Reset_Combo_Mod();
        }

        Progress_Effects();

        if (curr_character_num % 2 == 0)
        {
            Spawn_Mana_Orb();
            Spawn_Mana_Orb();
        }

        curr_character_num = curr_character_num + 1;
        if (curr_character_num >= characters.Count)
        {
            curr_character_num = 0;
        }

        curr_player.GetComponent<Animator>().SetBool("Selected", false);
        curr_player = turn_order[curr_character_num];
        if (curr_player.GetComponent<Character_Script>().state == Character_States.Dead)
        {
            Prev_Player();
        }
        else
        {
            curr_player.GetComponent<Animator>().SetBool("Selected", true);
        }

        Clean_Reachable();

        //Start the new player's turn
        curr_player.GetComponent<Character_Script>().Start_Turn();
    }

    /// <summary>
    /// Called at the end of every character Turn to progress the timer on Tile Effects.
    /// </summary>
    public void Progress_Effects()
    {
        if (tile_effects != null && tile_effects.Count != 0)
        {
            foreach (GameObject obj in tile_effects)
            {
                obj.GetComponent<Tile_Effect>().Progress();
            }
        }
    }

    /// <summary>
    /// Used to end the current round and start a new round. 
    /// Increments the curr_round tracker.
    /// </summary>
    public void Next_Round()
    {
        curr_round += 1;
        
    }
}
