using UnityEngine;
using System.Collections;
using UnityEditor;
using System.Collections.Generic;
using System;
using System.IO;
using UnityEngine.SceneManagement;
using Newtonsoft.Json;

/// <summary>
/// The Scenario class is used to generate a battle map with an objective for the Player to meet. 
/// </summary>
[Serializable]
public class Scenario : MonoBehaviour {
    //Constants
    /// <summary>
    /// Constants:
    /// static string PLAYER_STATS_FILE - File from which to draw Character stats.
    /// static string MONSTER_STATS_FILE - File from which to draw Monster Stats.
    /// static Scenario scenario - Makes sure there is only one copy of this. 
    /// 
    /// Variables:
    /// Tile_Grid tile_grid  - The tile_grid object that contains the array of Tile Objects that acts as the map for the Scenario.
	/// Game_Controller controller - The Game Controller Object in charge of overarching game processes.
    /// string scenario_file - The file from which the Scenario reads in its values.
    /// int scenario_id - The ID used to separate this Scenario from others. Also used for Scenario selection from the available_scenarios list.
    /// string scenario_sector - The sector the Scenario can appear in. Not in use yet.
    /// string scenario_name - The Name of the Scenario.
    /// string description - The descrition for the Scenario.
    /// Scenario_Objectives objective - The Objective for the Scenario. Defined how to win the Scenario.
    /// List<string> rewards - The Rewards for completing the Scenario's Objective.
    /// string bonus_objective - The Bonus Objective for the Scenario. Defines how to earn the Bonus Rewards for the Scenario.
    /// List<string> bonus_rewards - The Rewards for completing the Scenario's Bonus Objective.
    /// List<int> unlocks_scenarios - Scenarios that will be added to the available_scenarios List regardless of outcome.
    /// List<int> unlocks_scenarios_on_loss - Scenarios that will be added to the available_scenarios List if the Player does not achieve the Objective.
    /// List<int> unlocks_scenarios_on_win - Scenarios that will be added to the available_scenarios List if the Player achieves the Objective.
    /// List<int> unlocks_scenarios_on_bonus - Scenarios that will be added to the available_scenarios List if the Player achieves the Bonus Objective. 
    /// Stack<GameObject> curr_character - The Character that is currently Acting.
    /// GameObject cursor - The Cursor Object is used to select Tiles and Characters for Actions. It shows which Tile Object the player's mouse is over.
    /// List<GameObject> cursors - The List of currently active Cursor Objects. Multiple Cursors are necessary because of AoE Actions.
    /// String cursor_name - Stores the current Character's Action so we can tell if we need to change the number of Cursor Objects in the cursors List.
    /// int curr_character_num - The index for the current character in the characters Array.
    /// ArrayList characters - The list of all currently Active Characters in the scenario.
    /// List<> tile_objects - The list of all Objects currently Active in the scenario.
    /// List<Hazard> hazards - The list of all Tile_effects. USed to decrement their timers at the end of a round.
    /// Character_Script[] player_character_data - The Array of Character scripts holding data for all available player Characters. 
    ///     Generated by the PLAYER_STATS_FILE.
    /// Character_Script[] monster_character_data - The Array of Character scripts holding data for all available monster Characters. 
    ///     Generated by the MONSTER_STATS_FILE.
    /// List<GameObject> turn_order - The List of Characters sorted by Dexterity to determine turn order.
    /// Transform clicked_tile - The Tile object curretly Clicked by the Player.
    /// Transform selected_tile - The Tile object currently Selected by the Player. Also where the main cursor Object should be.
    /// List<Transform> reachable_tiles - The List of tiles that are reachable for the current Character's current Action
    /// List<GameObject> reachable_tile_objects - The List of Objects used to mark what Tiles are Reachable.
    /// int curr_round - The number of the current round. Not currently in Use.

    /// </summary>
    /// File Locations
    private static string OBJECT_SPRITESHEET_FILE = "Sprites/Object Sprites/object_spritesheet_transparent";
    private static string OBJECT_PREFAB_SRC = "Prefabs/Scenario Prefabs/Object Prefabs/object_prefab";
    private static string HAZARD_PREFAB_SRC = "Prefabs/Scenario Prefabs/Hazard Prefabs/hazard_prefab";
    private static string EMPTY_PREFAB_SRC = "Prefabs/Scenario Prefabs/empty_prefab";
    private static string CHARACTER_PREFAB_SRC = "Prefabs/Character_Prefab/Character_Prefab";
    private static string PLAYER_STATS_FILE = "Assets/Resources/Characters/Player_Characters/Player_Character_Data.txt";
    private static string MONSTER_STATS_FILE = "Assets/Resources/Characters/Monster_Characters/Monster_Character_Data.txt";
    private static string REACHABLE_MATS = Tile.MAT_FOLDER + "Reachable_Tile_Materials/";
    private static string CURSOR_MATS = Tile.MAT_FOLDER + "Cursor_Materials/";
    private static string REACHABLE_PREFAB_SRC = "Prefabs/Scenario Prefabs/Tile Prefabs/Reachable";
    private static string SCENARIOS_FOLDER = "Scenarios";
    private static string MAPS_FOLDERS = "Maps";
    private static Scenario scenario;

    //Grid size constants 
    private static int MAX_WIDTH = 40;
    private static int MAX_LENGTH = 40;
    private static int MAX_HEIGHT = 30;
    private static int MIN_WIDTH = 5;
    private static int MIN_LENGTH = 5;
    private static int MIN_HEIGHT = 1;
    
    //Starting coordinates for the grid;
    public static int START_X = 0;
    public static int START_Y = -7;
    public static int START_Z = 0;
    public static float TILE_WIDTH = 1.5f;
    public static float TILE_LENGTH = 1.5f;
    public static float TILE_HEIGHT = 0.5f;
    public static float TILE_SCALE_X = 75.0f;
    public static float TILE_SCALE_Y = 75.0f;
    public static float TILE_SCALE_Z = 350.0f;
    public static float COLL_SCALE = .02f;

    //Duration of the elevate animation
    private static float ELEVATE_DURATION = 0.3f;

    [JsonProperty] public string scenario_id { get; private set; }
    [JsonProperty] public string scenario_sector { get; private set; }
    [JsonProperty] public string scenario_name { get; private set; }
    [JsonProperty] public string description { get; private set; }
    [JsonProperty] public Scenario_Objectives objective { get; private set; }
    [JsonProperty] public List<string> rewards { get; private set; }
    [JsonProperty] public string bonus_objective { get; private set; }
    [JsonProperty] public List<string> bonus_rewards { get; private set; }
    [JsonProperty] public List<int> unlocks { get; private set; }
    [JsonProperty] public List<int> unlocks_on_loss { get; private set; }
    [JsonProperty] public List<int> unlocks_on_win { get; private set; }
    [JsonProperty] public List<int> unlocks_on_bonus { get; private set; }
    [JsonProperty] public Stack<GameObject> curr_character { get; private set; }
    [JsonProperty] public int curr_character_num { get; private set; }
    [JsonProperty] public List<GameObject> turn_order { get; private set; }
    [JsonProperty] public Tile[,] tiles { get; private set; }
    [JsonProperty] public int curr_round { get; private set; }
    [JsonProperty] public string prev_scenario { get; private set; }
    [JsonProperty] public string next_scenario { get; private set; }

    //Non-serialized variables.
    //Dictionaries
    public SortedDictionary<int, GameObject> characters { get; private set; }
    public SortedDictionary<int, GameObject> tile_objs { get; private set; }
    public SortedDictionary<int, GameObject> hazards { get; private set; }

    //Prefabs
    GameObject object_prefab;
    GameObject hazard_prefab;
    GameObject empty_prefab;
    GameObject reachable_prefab;
    GameObject character_prefab;

    //Reachable tile 
    List<Material> reachable_tile_materials;
    List<GameObject> reachable_tile_objects;
    public List<Tile> reachable_tiles { get; private set; }
    Stack<Tile> visited_tiles;

    //Character_Script[] player_character_data;
    //Character_Script[] monster_character_data;
    public Tile clicked_tile { get; set; }
    public Tile selected_tile { get; set; }
    
    //cursors
    GameObject cursor;
    List<GameObject> cursors;
    String cursor_name;

    public int Get_Width()
    {
        return tiles.GetLength(0);
    }
    public int Get_Length()
    {
        return tiles.GetLength(1);
    }
    public Tile Get_Tile(int x, int y)
    {
        Tile tile = null;
        try
        {
            tile = tiles[x, y];
        }
        catch (IndexOutOfRangeException e)
        {
            Debug.Log("Tile [" + x + "," + y + "] could not be found");
        }
        return tile;
    }
    public Character_Script Get_Curr_Character()
    {
        if (curr_character != null && curr_character.Count >= 0)
        {
            return curr_character.Peek().GetComponent<Character_Script>();
        }
        return null;
    }
    public Character_Action Get_Curr_Character_Action()
    {
        return curr_character.Peek().GetComponent<Character_Script>().Get_Curr_Action();
    }
    /// <summary>
    /// Prints the entire graph, edge by edge.
    /// </summary>
    public void Print_Graph()
    {
        foreach (Tile t in tiles)
        {
            t.printEdges();
        }
    }

    public void Set_Id(string id)
    {
        if (SceneManager.GetActiveScene().name == "Editor")
        {
            scenario_id = id;
        }
    }
    public void Set_Name(string name)
    {
        if (SceneManager.GetActiveScene().name == "Editor")
        {
            scenario_name = name;
        }
    }
    public void Set_Sector(string sector)
    {
        if (SceneManager.GetActiveScene().name == "Editor")
        {
            scenario_sector = sector;
        }
    }
    public void Set_Description(string desc)
    {
        if (SceneManager.GetActiveScene().name == "Editor")
        {
            description = desc;
        }
    }
    public void Set_Objective(int value)
    {
        if (SceneManager.GetActiveScene().name == "Editor")
        {
            objective = (Scenario_Objectives)value;
        }
    }
    public void Set_Prev(string scenario)
    {
        if (SceneManager.GetActiveScene().name == "Editor")
        {
            prev_scenario = scenario;
        }
    }
    public void Set_Next(string scenario)
    {
        if (SceneManager.GetActiveScene().name == "Editor")
        {
            next_scenario = scenario;
        }
    }
    public void Push_Curr_Character(GameObject chara)
    {
        curr_character.Push(chara);
    }
    public void Pop_Curr_Character()
    {
        curr_character.Pop();
    }
    /// <summary>
    /// Add a Tile to the Tile array with default parameters.
    /// </summary>
    /// <param name="x">The x index of the Tile to add</param>
    /// <param name="y">The y index of the Tile to add</param>
    public void Add_Tile(int x, int y)
    {
        //If a Tile is already present, destroy it.
        if (tiles[x, y] != null)
        {
            Debug.Log("Clearing tile " + x + "," +y);
            Destroy(tiles[x, y].gameObject);
        }

        //Instantiate the tile object.
        string file = Tile.TILE_MESHES + Tile.TILE_OBJECT_PREFIX + "0";

        GameObject tile3d = Resources.Load(file, typeof(GameObject)) as GameObject;

        GameObject instance = ((GameObject)Instantiate(tile3d,
            new Vector3((float)(START_X - TILE_WIDTH * y),
                (float)(START_Y + TILE_HEIGHT * 1),
                (float)(START_Z - TILE_LENGTH * x)),
            Quaternion.identity));
        instance.transform.localScale = new Vector3(TILE_SCALE_X, TILE_SCALE_Y, TILE_SCALE_Z);

        instance.transform.Rotate(new Vector3(1, 0, 0), -90);

        //Set the parent to be the Scenario object Tile_Grid
        instance.transform.parent = transform.GetChild(0).GetChild(x);

        //Change the object name to be the tile index
        instance.name = "[" + x + "," + y + "]";

        //Change the Tag to be a Tile
        instance.tag = "Tile";

        //Add a collider to the tile (TEMPORARY)
        BoxCollider collider = instance.AddComponent<BoxCollider>();
        collider.size = new Vector3(COLL_SCALE, COLL_SCALE, 0);
        collider.center = new Vector3(0, 0, COLL_SCALE);

        //Set the material
        Material material = (Material)Resources.Load(Tile.DEFAULT_MAT);
        instance.GetComponentInChildren<Renderer>().material = material;

        //Generate the tile data for the tile
        instance.AddComponent<Tile>();
        Tile tile = instance.GetComponent<Tile>();
        tile.Instantiate(x, y);
        tiles[x, y] = tile;
    }

    /// <summary>
    /// Add a Tile to the Tile array using pre-existing data.
    /// </summary>
    /// <param name="data">The Tile_Data to use to generate the Tile</param>
    public void Add_Tile(Tile_Data data)
    {
        int x = data.index[0];
        int y = data.index[1];

        //If a Tile is already present, destroy it.
        if (tiles[x, y] != null)
        {
            Destroy(tiles[x, y].gameObject);
        }

        //Instantiate the tile object.
        string file = Tile.TILE_MESHES + Tile.TILE_OBJECT_PREFIX + data.tile_type;

        GameObject tile3d = Resources.Load(file, typeof(GameObject)) as GameObject;

        GameObject instance = ((GameObject)Instantiate(tile3d,
            new Vector3((float)(START_X - TILE_WIDTH * y),
                (float)(START_Y + TILE_HEIGHT * data.height),
                (float)(START_Z - TILE_LENGTH * x)),
            Quaternion.identity));
        instance.transform.localScale = new Vector3(TILE_SCALE_X, TILE_SCALE_Y, TILE_SCALE_Z);

        instance.transform.Rotate(new Vector3(1, 0, 0), -90);

        //Set the parent to be the Scenario object Tile_Grid
        instance.transform.parent = transform.GetChild(0).GetChild(x);

        //Change the object name to be the tile index
        instance.name = "[" + x + "," + y + "]";

        //Change the Tag to be a Tile
        instance.tag = "Tile";

        //Add a collider to the tile (TEMPORARY)
        BoxCollider collider = instance.AddComponent<BoxCollider>();
        collider.size = new Vector3(COLL_SCALE, COLL_SCALE, 0);
        collider.center = new Vector3(0, 0, COLL_SCALE);
        if (data.height <= 0)
        {
            instance.GetComponentsInChildren<MeshRenderer>()[0].enabled = false;
            if (SceneManager.GetActiveScene().name != "Editor") {
                collider.enabled = false;
            }
        }
        //Set the material
        Material material = (Material)Resources.Load(Tile.TILE_MATS + data.material);
        instance.GetComponentInChildren<Renderer>().material = material;

        //Generate the tile data for the tile
        instance.AddComponent<Tile>();
        Tile tile = instance.GetComponent<Tile>();
        tiles[x, y] = tile;
        tile.Instantiate(data);
    }

    /// <summary>
    /// Add a Hazard to a specific tile.
    /// </summary>
    /// <param name="tile">The Tile on which to add the Hazard</param>
    /// <param name="data">The data to give the Hazard</param>
    public void Add_Hazard(Tile tile, Hazard_Data data)
    {
        GameObject prefab = hazard_prefab;

        //Instantiate the prefab
        GameObject obj = ((GameObject)Instantiate(prefab,
            new Vector3((float)(tile.transform.position.x + (-START_X)),
                (float)(tile.transform.position.y + (-START_Y)),
                (float)(tile.transform.position.z + (-START_Z))),
            Quaternion.identity));

        //Set the object parent to be the Hazards
        obj.transform.parent = Game_Controller.Get_Curr_Scenario().transform.GetChild(2);

        obj.name = data.hazard_name;

        //Give the object the correct data
        obj.GetComponent<Hazard>().Instantiate(data);

        //Update the Tile with the object reference.
        tiles[tile.index[0], tile.index[1]].Set_Hazard(obj);

        //Add the new hazard to the hazard list.
        hazards[obj.GetComponent<Hazard>().Get_Scenario_ID()] = obj;
    }

    /// <summary>
    /// Add an Object to a a specific Tile
    /// </summary>
    /// <param name="tile">The Tile to add the Object to</param>
    /// <param name="data">The data to put into the Object_Script</param>
    public void Add_Object(Tile tile, Object_Script_Data data)
    {
        GameObject prefab = object_prefab;

        //Instantiate the prefab
        GameObject obj = ((GameObject)Instantiate(prefab,
            new Vector3((float)(tile.transform.position.x + (-START_X)),
                (float)(tile.transform.position.y + (-START_Y)),
                (float)(tile.transform.position.z + (-START_Z))),
            Quaternion.identity));

        //Set the object parent to be the Hazards
        obj.transform.parent = transform.GetChild(1);

        obj.name = data.obj_name;

        //Give the object the correct data
        obj.GetComponent<Object_Script>().Instantiate(data);

        //Update the Tile with the object reference.
        tiles[tile.index[0], tile.index[1]].Set_Obj(obj);

        //Add the new hazard to the hazard list.
        tile_objs[obj.GetComponent<Object_Script>().Get_Scenario_ID()] = obj;
    }

    /// <summary>
    /// Adds a Character Script object to a Tile.
    /// </summary>
    /// <param name="tile">The Tile which to add the object to.</param>
    /// <param name="data">The data to feed to the Character_Script</param>
    public void Add_Character(Tile tile, Character_Script_Data data)
    {
        GameObject prefab = character_prefab;
        //Calculate offsets
        float height_offset = (prefab.GetComponent<SpriteRenderer>().sprite.rect.height *
            prefab.transform.localScale.y /
            prefab.GetComponent<SpriteRenderer>().sprite.pixelsPerUnit /
            2);
        float offset = (height_offset) / 3.5f;

        //Instantiate the prefab
        GameObject obj = ((GameObject)Instantiate(prefab,
            new Vector3((float)(tile.transform.position.x + (-START_X)),
                (float)(tile.transform.position.y + (-START_Y)),
                (float)(tile.transform.position.z + (-START_Z))),
            Quaternion.identity));

        //Set the object parent to be the Hazards
        obj.transform.parent = transform.GetChild(3);

        obj.name = data.character_name;

        //Give the object the correct data
        obj.GetComponent<Character_Script>().Instantiate(data);

        //Update the Tile with the object reference.
        tiles[tile.index[0], tile.index[1]].Set_Character(obj);

        //Add the new character to the characters list.
        characters[obj.GetComponent<Character_Script>().Get_Scenario_ID()] = obj;
    }

    /// <summary>
    /// Instantiate a set of tiles with default parameters. 
    /// </summary>
    /// <param name="width">Width of the grid to instantiate</param>
    /// <param name="length">Length of the grid to instantiate</param>
    public void Instantiate_Tiles(int width, int length)
    {
        for (int x = 0; x < tiles.GetLength(0); x++)
        {
            GameObject empty = ((GameObject)Instantiate(empty_prefab,
                    new Vector3(0,
                        0,
                        0),
                    Quaternion.identity));

            //Set empty object as father for a row.
            empty.transform.parent = transform.GetChild(0);

            //Change the object name to be the tile index
            empty.name = "Row " + x;

            for (int y = 0; y < tiles.GetLength(1); y++)
            {
                Add_Tile(x, y);
            }
        }
    }

    /// <summary>
    /// Instantiate a set of tiles with previous data to copy. 
    /// </summary>
    /// <param name="data">An array of Tile_Data to copy</param>
    public void Instantiate_Tiles(Tile_Data[,] data)
    {
        for (int x = 0; x < tiles.GetLength(0); x++)
        {
            GameObject empty = ((GameObject)Instantiate(empty_prefab,
                    new Vector3(0,
                        0,
                        0),
                    Quaternion.identity));

            //Set empty object as father for a row.
            empty.transform.parent = transform.GetChild(0);

            //Change the object name to be the tile index
            empty.name = "Row " + x;

            for (int y = 0; y < tiles.GetLength(1); y++)
            {
                Add_Tile(data[x,y]);
            }
        }
    }


    /// <summary>
    /// TODO: Fix this method later.
    /// </summary>
    /// <param name="chara"></param>
    public void Remove_Character(GameObject chara)
    {
        if (chara.GetComponent<Character_Script>())
        {
            characters.Remove(chara.GetComponent<Character_Script>().Get_Scenario_ID());
            turn_order.Remove(chara);
        }

    }

    public Scenario Parse_Json(string json)
    {
        Scenario scen = JsonUtility.FromJson<Scenario>(json);
        //Debug.Log("act name " + act.name);
        if (scen != null && scen.scenario_name != "")
        {
            return scen;
        }
        else
        {
            Debug.Log("Invalid JSON: " + json);
        }
        return null;
    }

    /// <summary>
    /// Creates a default scenario given a width and length.
    /// </summary>
    /// <param name="width">The width of the Tile_Grid to create.</param>
    /// <param name="length">The length of the Tile_Grid to create.</param>
    public void Initialize(int width, int length)
    {
        //Set up prefabs
        object_prefab = Resources.Load(OBJECT_PREFAB_SRC, typeof(GameObject)) as GameObject;
        hazard_prefab = Resources.Load(HAZARD_PREFAB_SRC, typeof(GameObject)) as GameObject;
        empty_prefab = Resources.Load(EMPTY_PREFAB_SRC, typeof(GameObject)) as GameObject;
        character_prefab = Resources.Load(CHARACTER_PREFAB_SRC, typeof(GameObject)) as GameObject;
        reachable_prefab = Resources.Load(REACHABLE_PREFAB_SRC, typeof(GameObject)) as GameObject;

        scenario_id = "0";
        scenario_sector = "0";
        scenario_name = "New Scenario";
        description = "A new Scenario";
        objective = Scenario_Objectives.Vanquish;
        rewards = new List<string> { "None" };
        bonus_objective = "None";
        bonus_rewards = new List<string> { "None" };
        unlocks = new List<int> { 0 };
        unlocks_on_loss = new List<int>();
        unlocks_on_win = new List<int>();
        unlocks_on_bonus = new List<int>();
        curr_character = new Stack<GameObject>();
        curr_character_num = 0;
        turn_order = new List<GameObject>();
        tiles = new Tile[width,length];
        curr_round = 0;
        prev_scenario = "-1";
        next_scenario = "-1";

        //Set up dictionaries
        tile_objs = new SortedDictionary<int, GameObject>();
        hazards = new SortedDictionary<int, GameObject>();
        characters = new SortedDictionary<int, GameObject>();

        //Set up the Tiles
        Instantiate_Tiles(width, length);

        visited_tiles = new Stack<Tile>();

        //cursors
        cursor_name = "None";
        cursors = new List<GameObject>();
        GameObject[] temp = GameObject.FindGameObjectsWithTag("Cursor");
        foreach (GameObject obj in temp)
        {
            cursors.Add(obj);
        }
        cursor = cursors[0];

        //reachable tiles
        reachable_tile_materials = new List<Material>();
        for (int i = 0; i < 2; i++)
        {
            reachable_tile_materials.Add(Resources.Load(REACHABLE_MATS + "Reachable_Tile_0" + i, typeof(Material)) as Material);
        }
        reachable_tile_objects = new List<GameObject>();
        reachable_tiles = new List<Tile>();

        //Set initial values for clicked and selected tiles.
        selected_tile = tiles[0, 0];
        clicked_tile = tiles[0, 0];

        //Recenter the camera to the tile grid location
        Camera.main.gameObject.GetComponent<Camera_Controller>().Center_Camera();

    }

    /// <summary>
    /// Initialize a Scenario with previous Scenario_Data.
    /// </summary>
    /// <param name="data">The data to use to recreate the Scenario</param>
    public void Initialize(Scenario_Data data)
    {
        //Set up prefabs
        object_prefab = Resources.Load(OBJECT_PREFAB_SRC, typeof(GameObject)) as GameObject;
        hazard_prefab = Resources.Load(HAZARD_PREFAB_SRC, typeof(GameObject)) as GameObject;
        empty_prefab = Resources.Load(EMPTY_PREFAB_SRC, typeof(GameObject)) as GameObject;
        character_prefab = Resources.Load(CHARACTER_PREFAB_SRC, typeof(GameObject)) as GameObject;
        reachable_prefab = Resources.Load(REACHABLE_PREFAB_SRC, typeof(GameObject)) as GameObject;

        scenario_id = data.scenario_id;
        scenario_sector = data.scenario_sector;
        scenario_name = data.scenario_name;
        description = data.description;
        objective = data.objective;
        rewards = data.rewards;
        bonus_objective = data.bonus_objective;
        bonus_rewards = data.bonus_rewards;
        unlocks = data.unlocks;
        unlocks_on_loss = data.unlocks_on_loss;
        unlocks_on_win = data.unlocks_on_win;
        unlocks_on_bonus = data.unlocks_on_bonus;
        curr_character_num = data.curr_character_num;

        tiles = new Tile[data.tiles.GetLength(0), data.tiles.GetLength(1)];
        curr_round = data.curr_round;
        prev_scenario = data.prev_scenario;
        next_scenario = data.next_scenario;

        //Set up dictionaries
        tile_objs = new SortedDictionary<int, GameObject>();
        hazards = new SortedDictionary<int, GameObject>();
        characters = new SortedDictionary<int, GameObject>();

        //Set up the Tiles
        Instantiate_Tiles(data.tiles);

        curr_character = new Stack<GameObject>();
        foreach (int id in data.curr_character_ids)
        {
            curr_character.Push(characters[id].gameObject);
        }
        turn_order = new List<GameObject>();
        foreach (int id in data.turn_order_ids)
        {
            turn_order.Add(characters[id].gameObject);
        }

        visited_tiles = new Stack<Tile>();

        //cursors
        cursor_name = "None";
        cursors = new List<GameObject>();
        GameObject[] temp = GameObject.FindGameObjectsWithTag("Cursor");
        foreach (GameObject obj in temp)
        {
            cursors.Add(obj);
        }
        cursor = cursors[0];

        //reachable tiles
        reachable_tile_materials = new List<Material>();
        for (int i = 0; i < 2; i++)
        {
            reachable_tile_materials.Add(Resources.Load(REACHABLE_MATS + "Reachable_Tile_0" + i, typeof(Material)) as Material);
        }
        reachable_tile_objects = new List<GameObject>();
        reachable_tiles = new List<Tile>();

        //Set initial values for clicked and selected tiles.
        selected_tile = tiles[0, 0];
        clicked_tile = tiles[0, 0];

        //Recenter the camera to the tile grid location
        Camera.main.gameObject.GetComponent<Camera_Controller>().Center_Camera();
    }

    /// <summary>
    /// Function for Raising/Lowering tiles.
    /// </summary>
    /// <param name="target">The target tile to Raise/Lower</param>
    /// <param name="height">The height to change the tile.</param>
    public IEnumerator Elevate(Transform target, int height)
    {
        //Modify tile height
        Tile tile = target.GetComponent<Tile>();
        tile.Set_Height(tile.height + height);

        //Modify object
        //string file = TILE_MESHES + tile.height + TILE_OBJECT_SUFFIX;
        //tile.gameObject.GetComponentsInChildren<MeshFilter>()[0].mesh = Resources.Load(file, typeof(Mesh)) as Mesh;

        //Move the tile and any objects on it to the right place.
        float elapsedTime = 0;
        float duration = ELEVATE_DURATION;
        Vector3 tile_start = new Vector3(tile.transform.position.x,
                        (float)(TILE_HEIGHT * (-height)),
                        tile.transform.position.z);
        Vector3 tile_end = tile.transform.position;
        Vector3 obj_start = new Vector3(0, 0, 0);
        Vector3 obj_end = new Vector3(0, 0, 0);
        if (tile.Has_Object())
        {
            obj_start = tile.obj.transform.position;
            Vector3 camera_offset = new Vector3(0, 0, 0);
            float height_offset = 0.5f;
            Character_Script chara = tile.obj.GetComponent<Character_Script>();
            if (chara != null)
            {
                camera_offset = chara.camera_position_offset;
                height_offset = chara.height_offset;
            }
            obj_end = tile.transform.position +
                camera_offset +
                new Vector3(0, TILE_HEIGHT * tile.height + height_offset, 0);
        }
        while (elapsedTime < duration)
        {
            tile.transform.position = Vector3.Lerp(tile_start, tile_end, elapsedTime / duration);
            if (tile.Has_Object())
            {
                tile.obj.transform.position = Vector3.Lerp(obj_start, obj_end, elapsedTime / duration);
            }
            elapsedTime += Time.deltaTime;
            yield return new WaitForEndOfFrame();
        }
        tile.transform.position = tile_end;

        //Modify the collider
        BoxCollider collider = tile.gameObject.GetComponent<BoxCollider>();

        collider.size = new Vector3(TILE_LENGTH * COLL_SCALE, 0, TILE_WIDTH * COLL_SCALE);
        collider.center = new Vector3(0, tile.height, 0);

        //Modify navmesh
        foreach (Edge e in tile.edges)
        {
            //Modify local edges
            if (e != null)
            {
                e.Update_Cost(e.tile2);

                //Debug.Log("Edge between (" + e.tile1.index[0] + "," + e.tile1.index[1] + ") and (" + e.tile2.index[0] + "," + e.tile2.index[1] + ") has cost " + e.cost);
                //modify edges of adjacent nodes
                foreach (Edge edge in e.tile2.edges)
                {
                    if (edge != null)
                    {
                        if (edge.tile2.Equals(e.tile1))
                        {
                            edge.Update_Cost(e.tile1);
                            //edge.tile2 = e.tile1;
                            //Debug.Log("Edge between (" + edge.node1.index[0] + ", " + edge.node1.index[1] + ") and(" + edge.node2.index[0] + ", " + edge.node2.index[1] + ") has cost " + edge.cost);
                        }
                    }
                }
            }
        }

        //Destroy old object 
        //Destroy(tile.gameObject);
    }

    /// <summary>
    /// Exports data about the scenario as a file.
    /// </summary>
    public Scenario_Data Export_Data()
    {
        if (Check_Valid())
        {
            Scenario_Data data = new Scenario_Data(this);
            data.Print_Json();
            return data;
        }
        else
        {
            Game_Controller.Create_Error_Message("Scenario is not Valid.");
        }
        return null;
    }
    
    /// <summary>
    /// Checks to see if a Scenario is playable.
    /// </summary>
    /// <returns></returns>
    public bool Check_Valid()
    {
        //TODO add content here for an accurate check
        return true;
    }

    public double Generate_Id(double i, GameObject obj)
    {
        double add = 0.0000;
        if(obj.GetComponent<Hazard>() != null)
        {

        }
        else if (obj.GetComponent<Object_Script>() != null)
        {

        }else if (obj.GetComponent<Character_Script>() != null)
        {

        }
        return i + add;
    }

    /// <summary>
    /// Constructor for the Class. Asks for a file from which to parse its fields.
    /// </summary>
    /// <param name="filename">The file from which to get its fields.</param>
    /*public Scenario(string filename)
    {
        reachable_prefab = Resources.Load(REACHABLE_PREFAB_SRC, typeof(GameObject)) as GameObject;
        scenario_file = filename;
        //Initialize Lists
        rewards = new List<string>();
        bonus_rewards = new List<string>();
        List<int> unlocks_scenarios = new List<int>();
        List<int> unlocks_scenarios_on_loss = new List<int>();
        List<int> unlocks_scenarios_on_win = new List<int>();
        List<int> unlocks_scenarios_on_bonus = new List<int>();
        //Read in the file
        string[] lines = System.IO.File.ReadAllLines(scenario_file);
        string line = "";
        string[] elements = new string[2];
        //30 is the default grid size;
        int grid_width=30;
        int grid_length=30;
        Material[] materials = new Material[10];
        double[] tile_modifiers = new double[10];
        int[,] tile_mat_ids = new int[grid_width, grid_length];
        int[,] object_sprite_ids = new int[grid_width, grid_length];
        int[,] character_ids = new int[grid_width, grid_length];
        //Read through the file line by line, looking for specific headings
        for (int i = 0; i < lines.Length; i++)
        {
            line = lines[i];
            switch (line)
            {
                //ID of the scenario
                case "[ID]":
                    scenario_name = lines[i + 1];
                    i += 2;
                    break;
                //What Sector the scenario can be found in
                case "[Sector]":
                    scenario_sector = lines[i + 1];
                    i += 2;
                    break;
                //Name of the Scenario
                case "[Name]":
                    scenario_name = lines[i + 1];
                    i+=2;
                    break;
                //Description for the Scenario
                case "[Description]":
                    description = lines[i + 1];
                    i += 2;
                    break;
                //Objective for the scenario (see Objectives enum for list of possible objectives.)
                case "[Objective]":
                    foreach (Scenario_Objectives obj in System.Enum.GetValues(typeof(Scenario_Objectives)))
                    {
                        if(obj.ToString() == lines[i + 1])
                        {
                            objective = obj;
                        }
                    }
                    i += 2;
                    break;
                //Reward for winning the scenario
                case "[Reward]":
                    for(int j = i+1; j<lines.Length; j++)
                    {
                        if (lines[j] != "")
                        {
                            rewards.Add(lines[j]);
                        }
                        else
                        {
                            i = j;
                            j = lines.Length;
                        }
                    }
                    break;
                //Bonus objective for the scenario
                case "[Bonus Objective]":
                    bonus_objective = lines[i + 1];
                    i += 2;
                    break;
                //Reward for completing the Bonus Objective
                case "[Bonus Reward]":
                    for (int j = i + 1; j < lines.Length; j++)
                    {
                        if (lines[j] != "")
                        {
                            bonus_rewards.Add(lines[j]);
                        }
                        else
                        {
                            i = j;
                            j = lines.Length;
                        }
                    }
                    break;
                //Scenario IDs that will be unlocked regardless of wether or not the Objective is met
                case "[Unlocks]":
                    elements = lines[i + 1].Split(';');
                    int id = scenario_id;
                    foreach (string s in elements)
                    {
                        if (int.TryParse(s, out id))
                        {
                            unlocks_scenarios.Add(id);
                        }
                    }
                    i += 2;
                    break;
                //Scenario IDs that will be unlocked if the Objective is not met
                case "[Unlocks on Loss]":
                    elements = lines[i + 1].Split(';');
                    id = scenario_id;
                    foreach (string s in elements)
                    {
                        if (int.TryParse(s, out id))
                        {
                            unlocks_scenarios_on_loss.Add(id);
                        }
                    }
                    i += 2;
                    break;
                //Scenario IDs that will be unlocked if the Objective is met
                case "[Unlocks on Win]":
                    elements = lines[i + 1].Split(';');
                    id = scenario_id;
                    foreach (string s in elements)
                    {
                        if (int.TryParse(s, out id))
                        {
                            unlocks_scenarios_on_win.Add(id);
                        }
                    }
                    i += 2;
                    break;
                //Scenario IDs that will be unlocked if the Bonus Objective is met
                case "[Unlocks on Bonus]":
                    elements = lines[i + 1].Split(';');
                    id = scenario_id;
                    foreach (string s in elements)
                    {
                        if (int.TryParse(s, out id))
                        {
                            unlocks_scenarios_on_bonus.Add(id);
                        }
                    }
                    i += 2;
                    break;
                //Size of the tile grid map
                case "[Grid Size]":
                    int width = 30;
                    int length = 30;
                    if (int.TryParse(lines[i + 1].Split(';')[0], out width))
                    {
                        grid_width = width;
                    }
                    if (int.TryParse(lines[i + 1].Split(';')[1], out length))
                    {
                        grid_length = length;
                    }
                    i += 2;
                    break;
                case "[Tiles]":
                    //build materials
                    materials = new Material[10];
                    for (int j = i + 1; j < i + 10 + 1; j++)
                    {
                        string[] entries = lines[j].Split(' ');
                        materials[(j-i-1)] = (Material)Resources.Load(TILE_MATS + "TileMat0" + (j-i-1));
                        materials[(j - i - 1)].name = entries[1];
                        materials[(j-i-1)].mainTexture = (Texture)Resources.Load("Textures/" + entries[1]);
                        double modifier;
                        if (double.TryParse(entries[2], out modifier))
                        {
                            tile_modifiers[j - i - 1] = modifier;
                        }
                    }

                    break;
                case "[Tile Map]":
                    tile_mat_ids = new int[grid_width, grid_length];
                    for( int k = i+1; k<i+grid_length+1; k++)
                    {
                        string[] entries = lines[k].Split(';');
                        for (int l = 0; l<grid_width; l++)
                        {
                            int sprite;
                            if (int.TryParse(entries[l], out sprite))
                            {
                                tile_mat_ids[k-i-1, l] = sprite;
                            }
                        }
                    }
                    break;
                case "[Object Map]":
                    object_sprite_ids = new int[grid_width, grid_length];
                    for (int k = i + 1; k < i + grid_length+1; k++)
                    {
                        string[] entries = lines[k].Split(';');
                        for (int l = 0; l < grid_width; l++)
                        {
                            int sprite;
                            if (int.TryParse(entries[l], out sprite))
                            {
                                object_sprite_ids[k-i-1, l] = sprite;
                            }
                        }
                    }
                    break;
                case "[Character Map]":
                    character_ids = new int[grid_width, grid_length];
                    for (int k = i + 1; k < i + grid_length + 1; k++)
                    {
                        string[] entries = lines[k].Split(';');
                        for (int l = 0; l < grid_width; l++)
                        {
                            int sprite;
                            if (int.TryParse(entries[l], out sprite))
                            {
                                character_ids[k - i - 1, l] = sprite;
                            }
                        }
                    }
                    break;
                //Default in case none of the above cases are met
                default:
                    break;
            }
            //Resume new scenario creation
            tile_grid = this.transform.GetChild(0).GetComponent<Tile_Grid>();
            tile_grid.Start();
            //tile_grid.Start(grid_width, grid_length, materials, tile_modifiers, tile_mat_ids, object_sprite_ids, character_ids);

            curr_round = 0;
            curr_character_num = 0;
            turn_order = new List<GameObject>();
            reachable_tiles = new List<Tile>();
            reachable_tile_objects = new List<GameObject>();
            tile_objects = new List<GameObject>();
        }
    }*/

    /// <summary>
    /// Function to read in Character data from a file. Returns a Character_Script array from the data within the file.
    /// </summary>
    /// <param name="file">The file from which to read in Character Scripts.</param>
    /// <returns>Character_Script Array constructed from the given file.</returns>
    Character_Script[] Read_Character_Data(string file)
    {
        string[] lines = System.IO.File.ReadAllLines(file);
        Character_Script[] objects = new Character_Script[lines.Length / 15];

        int count = 0;
        string name = "";
        int level = 1;
        int strength = 1;
        int dexterity = 1;
        int spirit = 1;
        int initiative = 1;
        int vitality = 1;
        int speed = 6;
        int canister_max = 1;
        string weapon = "Sword";
        string armor = "Light";
        string animator = "Beetleboar";
        float[] scale = new float[3];
        foreach (string line in lines)
        {
            string[] elements = line.Split(':');
            if (!elements[0].Contains("#") && elements.Length > 1)
            {
                if (elements[0] == "name")
                {
                    name = elements[1].Trim();
                }
                else if (elements[0] == "level")
                {
                    if (int.TryParse(elements[1], out level))
                    { }
                }
                else if (elements[0] == "strength")
                {
                    if (int.TryParse(elements[1], out strength))
                    { }
                }
                else if (elements[0] == "dexterity")
                {
                    if (int.TryParse(elements[1], out dexterity))
                    { }
                }
                else if (elements[0] == "spirit")
                {
                    if (int.TryParse(elements[1], out spirit))
                    { }
                }
                else if (elements[0] == "initiative")
                {
                    if (int.TryParse(elements[1], out initiative))
                    { }
                }
                else if (elements[0] == "vitality")
                {
                    if (int.TryParse(elements[1], out vitality))
                    { }
                }
                else if (elements[0] == "speed")
                {
                    if (int.TryParse(elements[1], out speed))
                    { }
                }
                else if (elements[0] == "canister_max")
                {
                    if (int.TryParse(elements[1], out canister_max))
                    { }
                }
                else if (elements[0] == "weapon")
                {
                    weapon = elements[1];
                }
                else if (elements[0] == "armor")
                {
                    armor = elements[1];
                }
                else if (elements[0] == "accessories")
                {

                }
                else if (elements[0] == "animator")
                {
                    animator = elements[1].Trim();
                }
                else if (elements[0] == "scale")
                {
                    string[] scales = elements[1].Split(',');
                    scale = new float[3];
                    int x = 0;
                    foreach (string s in scales)
                    {
                        if (float.TryParse(s.Trim(), out scale[x]))
                        { }
                        x++;
                    }
                    if(x == 1)
                    {
                        scale[1] = scale[0];
                        scale[2] = scale[0];
                    }

                }
            }
            if (elements[0] == "")
            {
                objects[count] = new Character_Script(name, level, strength, dexterity, spirit, initiative, vitality, speed, canister_max, weapon, armor, animator, scale);
                count++;
            }
        }
        return objects;
    }

    /// <summary>
    /// Function used to sort GameObjects by their Dexterity Stat. 
    /// </summary>
    /// <param name="o1">The first Object to Compare</param>
    /// <param name="o2">The second Object to Compare</param>
    /// <returns>1 if the first Object's Initiative is greater, 0 if they are equal, -1 if the second Object's Initiative is greater. </returns>
    public static int Sort_By_Dex(GameObject o1, GameObject o2)
    {
        Character_Script char1 = o1.GetComponent<Character_Script>();
        Character_Script char2 = o2.GetComponent<Character_Script>();
        if (char1 != null && char2 != null)
        {
            //Debug.Log("comparing " + char1.name + " and " + char2.name);
            //Debug.Log("init " + char1.initiative + " and " + char2.initiative);
            //Debug.Log("weight " + char1.weight + " and " + char2.weight);
            if (char1.initiative > char2.initiative)
            {
                //Debug.Log(char1.name + " has higher init than " + char2.name);
                return 1;
            }
            else if (char1.initiative < char2.initiative)
            {
                //Debug.Log(char1.name + " has lower init than " + char2.name);
                return -1;
            }
            else
            {
                if (char1.weight < char2.weight)
                {
                    //Debug.Log(char1.name + " has lower weight than " + char2.name);
                    return 1;
                }
                else if (char1.weight > char2.weight)
                {
                    //Debug.Log(char1.name + " has higher weight than " + char2.name);
                    return -1;
                }
                else
                {
                    //Debug.Log(char1.name + " has equal weight and init than " + char2.name);
                    float rand1  = UnityEngine.Random.Range(0f, 10.0f);
                    float rand2 = UnityEngine.Random.Range(0f, 10.0f);
                    //Debug.Log(rand1 + " and " + rand2);
                    if (rand1 < rand2)
                    {
                        return -1;
                    }
                    else if (rand1 > rand2)
                    {
                        return 1;
                    }
                    return 0;
                }
            }
        }
        return 0;
    }

    /// <summary>
    /// Function to Instantiate all of the relevant Scenario Tiles, Objects and Characters. Basically the Start method.
    /// </summary>
    /*public void Load_Scenario()
    {
        //Instantiate the actual tile objects
        tile_grid.Instantiate();

        //Load the reachable tile materials
        reachable_tile_materials = new List<Material>();
        for (int i =0; i< 2; i++)
        {
            reachable_tile_materials.Add(Resources.Load(REACHABLE_MATS + "Reachable_Tile_0"+i, typeof(Material)) as Material);
            //reachable_tile_materials.Add(Resources.Load(REACHABLE_MATS + "Reachable_Tile_0"+i+".mat", typeof(Material)) as Material);
        }

        //Load player and monster stats and come up with turn order
        player_character_data = Read_Character_Data(PLAYER_STATS_FILE);
        monster_character_data = Read_Character_Data(MONSTER_STATS_FILE);
        Character_Script[] character_data;
        int char_num = 0;
        characters = new ArrayList();

        cursor = GameObject.FindGameObjectWithTag("Cursor");
        cursors = new List<GameObject>();
        GameObject[] objects = GameObject.FindGameObjectsWithTag("Character (Friend)");

        hazards = new List<GameObject>();
        if (GameObject.FindGameObjectWithTag("Tile Effect"))
        {
            foreach (GameObject obj in GameObject.FindGameObjectsWithTag("Tile Effects"))
            {
                hazards.Add(obj);
            }
        }

        //set starting positions for players
        //TODO change this to read positions from the scenario file.
        foreach (GameObject game_object in objects)
        {
            characters.Add(game_object);

            //Get the character ID from the tile grid
            int char_id = game_object.GetComponent<Character_Script>().character_id;

            Character_Script char_data;
            if (char_id / 10000 == 1)
            {
                //Player
                char_data = new Character_Script(player_character_data[char_id % 100 - 1]);
                game_object.tag = "Character (Friend)";
            }
            else if (char_id / 10000 == 2 )
            {
                //Monster
                char_data = new Character_Script(monster_character_data[char_id % 100 -1]);
                game_object.tag = "Character (Enemy)";
            }
            else
            {
                char_data = monster_character_data[0];
            }
            game_object.GetComponent<Character_Script>().Instantiate(char_data, char_id, char_num, char_id/1000%10);
            turn_order.Add(game_object);
            char_num++;
        }

        //Get Objects
        objects = GameObject.FindGameObjectsWithTag("Object");
        foreach (GameObject game_object in objects)
        {
            tile_objects.Add(game_object);
        }

        turn_order.Sort(Sort_By_Dex);
        curr_character_num = characters.Count - 1;
        curr_character = new Stack<GameObject>();
        curr_character.Push(turn_order[curr_character_num]);
        curr_character.Peek().GetComponent<Animator>().SetBool("Selected", true);
        char_num = 0;
        curr_character.Peek().GetComponent<Character_Script>().Start_Turn();
        //controller.action_menu.GetComponent<Action_Menu_Script>().resetActions();
        //curr_character.Peek().GetComponent<Character_Script>().Find_Action_Local("Move").Select();
        //GetComponent<Character_Script>().state = Character_Script.States.Moving;
        //FindReachable(curr_character.GetComponent<Character_Script>().action_curr, curr_character.GetComponent<Character_Script>().SPEED);
        //MarkReachable();

        //Set empty triggers to populate Event Dictionary.
        foreach (Event_Trigger eve in Enum.GetValues(typeof(Event_Trigger)))
        {
            Event_Manager.AddHandler(eve, Game_Controller.Get_Controller().Get_All_Actions()["Move"].React);
        }

        //set initial values for selected and clicked tiles.
        selected_tile = tile_grid.tiles[0, 0];
        clicked_tile = tile_grid.tiles[0, 0];
    }
    */

    /// <summary>
    /// Function to remove all relevant Scenario Tiles, Objects and Characters. Used for cleaning up and switching between scenarios.
    /// </summary>
    public void Unload_Scenario()
    {
        //Remove all Empty Events in the event manager.
        foreach (Event_Trigger eve in Enum.GetValues(typeof(Event_Trigger)))
        {
            Event_Manager.RemoveHandler(eve, Game_Controller.controller.Get_All_Actions()["Move"].React);
        }

        //destroy the old map
        GameObject[] objects = GameObject.FindGameObjectsWithTag("Tile");
        foreach (GameObject game_object in objects)
        {
            Destroy(game_object);
        }
        objects = GameObject.FindGameObjectsWithTag("Object");
        foreach (GameObject game_object in objects)
        {
            Destroy(game_object);
        }

    }

    /// <summary>
    /// Creates a Hazard to restore Mana at a Random tile.
    /// </summary>
    public void Spawn_Mana_Orb()
    {
        bool spawned = false;
        string[] value = { "CMPC", "5" };
        
        while (!spawned)
        {
            int random_x = (int)(UnityEngine.Random.value * 100) % tiles.GetLength(0);
            int random_y = (int)(UnityEngine.Random.value * 100) % tiles.GetLength(1);
            Tile tile = tiles[random_x, random_y];
            if (tile.hazard == null && tile.obj == null && tile.traversible)
            {
                Debug.Log("Spawned manawell at: " + random_x + "," + random_y );
                //tile_grid.CreateEffect(tile.gameObject, "Manawell", new Action_Effect("") "Heal", 10, value, 1);
                //Hazard effect = new Hazard("Manawell", "Heal", 10, value, 1, tile.gameObject);
                //effect.Instantiate();
                spawned = true;
            }
        }
    }

    /// <summary>
    /// Use this for initialization
    /// </summary>
    void Start () {
    }

    /// <summary>
    /// Function to check if the scenario's victory condition has been met. Called every Update. 
    /// </summary>
    public void Check_For_Victory()
    {
        bool victory = true;

        //The Goal for Vanquish is to kill all Enemies on the board.
        if (objective == Scenario_Objectives.Vanquish)
        {

            foreach (GameObject character in characters.Values)
            {
                if (character != null && character.tag != "Player")
                {
                    victory = false;
                }
            }
        }
        if (victory)
        {
            Debug.Log("CONGRATULATIONS! YOU WON!!!");
        }
    }

    /// <summary>
    /// Resets the cursor to one tile width.
    /// </summary>
    public void Reset_Cursor()
    {
        //Destroy existing cursors
        for (int i = 1; i< cursors.Count; i++)
        {
            GameObject.Destroy(cursors[i]);
        }
        cursors = new List<GameObject>();
        cursors.Add(cursor);
    }

    /// <summary>
    /// Function to update the Cursor Object to match the current Character's current Action's Area of Effect. 
    /// </summary>
    /// <param name="selected_tile">The tile on which the Cursor Object is currently.</param>
    public void Update_Cursor(Tile selected_tile)
    {
        if (SceneManager.GetActiveScene().name != "Editor")
        {
            //Debug.Log("curr_character " + curr_character.Peek().GetComponent<Character_Script>().Get_Curr_Action().Count);
            if (curr_character.Count > 0 && curr_character.Peek().GetComponent<Character_Script>().Get_Curr_Actions().Count > 0)
            {
                Character_Script curr_chara = curr_character.Peek().GetComponent<Character_Script>();
                //Debug.Log("area Count " + curr_character.Get_Curr_Action().area.Count);
                //Debug.Log("area Count " + curr_character.Get_Curr_Action().area[0].Count);
                int area_width = curr_chara.Get_Curr_Action().area.GetLength(0);
                int area_length = curr_chara.Get_Curr_Action().area.GetLength(1);

                //Update cursor type to match current Ability
                if (cursor_name != curr_chara.Get_Curr_Action().name)
                {

                    //Destroy existing cursors
                    foreach (GameObject game_object in cursors)
                    {
                        //reachable_tile_objects.Remove(game_object);
                        GameObject.Destroy(game_object);
                    }
                    cursors = new List<GameObject>();
                    cursor_name = curr_chara.Get_Curr_Action().name;

                    //Recreate cursors based on type
                    for (int x = 0; x < area_width; x++)
                    {
                        for (int y = 0; y < area_length; y++)
                        {
                            if (curr_chara.Get_Curr_Action().area[x,y] != 0)
                            {
                                GameObject instance = Instantiate(cursor);
                                if (curr_chara.Get_Curr_Action().area[x,y] > 0 &&
                                    curr_chara.Get_Curr_Action().area[x,y] < .25f)
                                {
                                    instance.GetComponent<Renderer>().material = (Material)Resources.Load(CURSOR_MATS + "GoldMat");
                                }
                                if (curr_chara.Get_Curr_Action().area[x,y] >= .25f &&
                                    curr_chara.Get_Curr_Action().area[x,y] < .5f)
                                {
                                    instance.GetComponent<Renderer>().material = (Material)Resources.Load(CURSOR_MATS + "GoldMat");
                                }
                                if (curr_chara.Get_Curr_Action().area[x,y] >= .5f &&
                                    curr_chara.Get_Curr_Action().area[x,y] < .75f)
                                {
                                    instance.GetComponent<Renderer>().material = (Material)Resources.Load(CURSOR_MATS + "OrangeMat");
                                }
                                if (curr_chara.Get_Curr_Action().area[x,y] > .75f)
                                {
                                    instance.GetComponent<Renderer>().material = (Material)Resources.Load(CURSOR_MATS + "RedMat");
                                }
                                instance.name = "Temp_Cursor";
                                instance.transform.parent = GameObject.Find("Cursors").transform;
                                cursors.Add(instance);
                            }
                        }
                    }
                }
                //Debug.Log("Moving Cursors");
                //Update cursor positions
                if (curr_chara.Get_Curr_Actions().Count == 0 ||
                    curr_chara.Get_Curr_Action().area.GetLength(0) == 1)
                {

                    cursors[0].transform.position = new Vector3(
                        selected_tile.transform.position.x,
                        selected_tile.transform.position.y + (-START_Y) + .06f,
                        selected_tile.transform.position.z);
                }
                else if (curr_chara.Get_Curr_Action().area.GetLength(0) > 1)
                {
                    int startX = 0;
                    int startY = 0;
                    if (curr_chara.Get_Curr_Action().center == Character_Action.Center_Types.Target)
                    {
                        startX = selected_tile.index[0];
                        startY = selected_tile.index[1];
                    }
                    else if (curr_chara.Get_Curr_Action().center == Character_Action.Center_Types.Self)
                    {
                        startX = curr_chara.curr_tile.index[0];
                        startY = curr_chara.curr_tile.index[1];
                    }
                    startX -= area_width / 2;
                    startY -= area_length / 2;
                    int curs_index = 0;
                    for (int x = 0; x < area_width; x++)
                    {
                        for (int y = 0; y < area_length; y++)
                        {
                            if (curr_character.Peek().GetComponent<Character_Script>().Get_Curr_Action().area[x,y] != 0)
                            {
                                Tile tile = tiles[startX + x, startY + y];
                                if (tile != null)
                                {
                                    cursors[curs_index].transform.position = new Vector3(
                                        tile.transform.position.x,
                                        tile.transform.position.y + (-START_Y) +.025f,
                                        tile.transform.position.z);
                                    curs_index++;
                                }
                                else
                                {
                                    cursors[curs_index].transform.position = new Vector3(-10, -10, -10);
                                    curs_index++;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                cursors[0].transform.position = new Vector3(
                        selected_tile.transform.position.x,
                        selected_tile.transform.position.y + (-START_Y) + .025f,
                        selected_tile.transform.position.z);

            }
            if (Has_Current_Character() &&
                curr_character.Peek().GetComponent<Character_Script>().Has_Current_Action() &&
                curr_character.Peek().GetComponent<Character_Script>().Get_Curr_Action().path_type == Path_Types.Path &&
                curr_character.Peek().GetComponent<Character_Script>().state.Peek() == Character_States.Idle
                )
            {
                //Debug.Log("Current action is " + curr_character.Peek().GetComponent<Character_Script>().Get_Curr_Action().name);
                Show_Path();
            }
            else
            {
                //IF we have no path to follow the eliminate the current mesh.
                scenario.GetComponent<MeshFilter>().mesh = null;
            }
        }
        else
        {
            cursors[0].transform.position = new Vector3(
                    selected_tile.transform.position.x,
                    selected_tile.transform.position.y + (-START_Y) +.025f,
                    selected_tile.transform.position.z);
        }
    }

    /// <summary>
    /// Displays the path from the current character to the selected tile.
    /// </summary>
    public void Show_Path()
    {
        //Debug.Log("Showing Path");
        Tile cursor_tile = selected_tile;
        Character_Script chara = curr_character.Peek().GetComponent<Character_Script>();
        if (chara.Get_Curr_Action().curr_path != null &&
            (cursor_tile.parent != null || chara.Get_Curr_Action().curr_path.Count > 1) &&
            curr_character.Peek() != null)
        {
            //Debug.Log("Testing");
            Tile temp_tile = cursor_tile;
            Mesh mesh = new Mesh();
            List<Vector3> vertices = new List<Vector3>();
            List<Vector2> uv = new List<Vector2>();
            List<int> triangles = new List<int>();
            float width_modifier = 0.2f;
            float tile_width = 1.5f;
            int tri_x = 0;
            int curr_path_index = chara.Get_Curr_Action().curr_path.Count - 1;
            //while (temp_tile != chara.Get_Curr_Action().curr_path[chara.Get_Curr_Action().curr_path.Count -1])
            while (temp_tile != chara.curr_tile || (curr_path_index > 0))
            {
                //Calculate the difference in the x and y tile index
                int delta_x;
                int delta_y;
                Tile next_tile;
                if (temp_tile != chara.Get_Curr_Action().curr_path[curr_path_index] && curr_path_index == chara.Get_Curr_Action().curr_path.Count - 1)
                {
                    next_tile = temp_tile.parent;
                    if(next_tile == null && curr_path_index > 0)
                    {
                        temp_tile = chara.Get_Curr_Action().curr_path[curr_path_index];
                        next_tile = chara.Get_Curr_Action().curr_path[curr_path_index-1];
                        curr_path_index -= 2;
                    }
                }
                else
                {
                    next_tile = chara.Get_Curr_Action().curr_path[curr_path_index];
                    curr_path_index -= 1;
                }
                if(next_tile == null)
                {
                    break;
                }
                delta_x = temp_tile.index[0] - next_tile.index[0];
                delta_y = temp_tile.index[1] - next_tile.index[1];

                if ((temp_tile == cursor_tile && !chara.Get_Curr_Action().curr_path.Contains(cursor_tile)) || 
                    (temp_tile == chara.Get_Curr_Action().curr_path[chara.Get_Curr_Action().curr_path.Count - 1] && cursor_tile.parent == null))
                {
                    //Set up first triangle.

                    //create 3 vertices, one is alwasy centered, the other 2 change oriantaion depending on direction of triangle
                    vertices.Add(new Vector3(temp_tile.transform.position.x,
                                (temp_tile.transform.position.y + (-START_Y) + 0.027f + TILE_HEIGHT * temp_tile.height),
                                temp_tile.transform.position.z));
                    uv.Add(new Vector2(0, 1));
                    if (delta_x != 0)
                    {
                        vertices.Add(new Vector3(temp_tile.transform.position.x + tile_width * width_modifier,
                                    (temp_tile.transform.position.y + (-START_Y) + 0.027f + TILE_HEIGHT * temp_tile.height),
                                    temp_tile.transform.position.z + tile_width * width_modifier * delta_x));
                        vertices.Add(new Vector3(temp_tile.transform.position.x - tile_width * width_modifier,
                                    (temp_tile.transform.position.y + (-START_Y) + 0.027f + TILE_HEIGHT * temp_tile.height),
                                    temp_tile.transform.position.z + tile_width * width_modifier * delta_x));
                        vertices.Add(new Vector3(temp_tile.transform.position.x + tile_width * width_modifier,
                                    (temp_tile.transform.position.y + (-START_Y) + 0.027f + TILE_HEIGHT * temp_tile.height),
                                    temp_tile.transform.position.z + tile_width * width_modifier * delta_x*2));
                        vertices.Add(new Vector3(temp_tile.transform.position.x - tile_width * width_modifier,
                                    (temp_tile.transform.position.y + (-START_Y) + 0.027f + TILE_HEIGHT * temp_tile.height),
                                    temp_tile.transform.position.z + tile_width * width_modifier * delta_x*2));
                        vertices.Add(new Vector3(temp_tile.transform.position.x + tile_width * width_modifier*2,
                                    (temp_tile.transform.position.y + (-START_Y) + 0.027f + TILE_HEIGHT * temp_tile.height),
                                    temp_tile.transform.position.z + tile_width * width_modifier * delta_x*2));
                        vertices.Add(new Vector3(temp_tile.transform.position.x - tile_width * width_modifier*2,
                                    (temp_tile.transform.position.y + (-START_Y) + 0.027f + TILE_HEIGHT * temp_tile.height),
                                    temp_tile.transform.position.z + tile_width * width_modifier * delta_x*2));
                        uv.Add(new Vector2(1, 1));
                        uv.Add(new Vector2(0, 0));
                        uv.Add(new Vector2(1, 1));
                        uv.Add(new Vector2(0, 0));
                        uv.Add(new Vector2(1, 1));
                        uv.Add(new Vector2(0, 0));
                    }
                    else if (delta_y != 0)
                    {
                        vertices.Add(new Vector3(temp_tile.transform.position.x + tile_width * width_modifier * delta_y,
                                    (temp_tile.transform.position.y + (-START_Y) + 0.027f + TILE_HEIGHT * temp_tile.height),
                                    temp_tile.transform.position.z + tile_width * width_modifier));
                        vertices.Add(new Vector3(temp_tile.transform.position.x + tile_width * width_modifier * delta_y,
                                    (temp_tile.transform.position.y + (-START_Y) + 0.027f + TILE_HEIGHT * temp_tile.height),
                                    temp_tile.transform.position.z - tile_width * width_modifier));
                        vertices.Add(new Vector3(temp_tile.transform.position.x + tile_width * width_modifier * delta_y *2,
                                    (temp_tile.transform.position.y + (-START_Y) + 0.027f + TILE_HEIGHT * temp_tile.height),
                                    temp_tile.transform.position.z + tile_width * width_modifier));
                        vertices.Add(new Vector3(temp_tile.transform.position.x + tile_width * width_modifier * delta_y *2,
                                    (temp_tile.transform.position.y + (-START_Y) + 0.027f + TILE_HEIGHT * temp_tile.height),
                                    temp_tile.transform.position.z - tile_width * width_modifier));
                        vertices.Add(new Vector3(temp_tile.transform.position.x + tile_width * width_modifier * delta_y*2,
                                    (temp_tile.transform.position.y + (-START_Y) + 0.027f + TILE_HEIGHT * temp_tile.height),
                                    temp_tile.transform.position.z + tile_width * width_modifier*2));
                        vertices.Add(new Vector3(temp_tile.transform.position.x + tile_width * width_modifier * delta_y*2,
                                    (temp_tile.transform.position.y + (-START_Y) + 0.027f + TILE_HEIGHT * temp_tile.height),
                                    temp_tile.transform.position.z - tile_width * width_modifier*2));
                        uv.Add(new Vector2(1, 1));
                        uv.Add(new Vector2(0, 0));
                        uv.Add(new Vector2(1, 1));
                        uv.Add(new Vector2(0, 0));
                        uv.Add(new Vector2(1, 1));
                        uv.Add(new Vector2(0, 0));

                    }

                    //Draw triangle between vertices.
                    //Duplicate the triangle to make it visible from both sides. 
                    triangles.Add(tri_x);
                    triangles.Add(tri_x + 1);
                    triangles.Add(tri_x + 2);
                    triangles.Add(tri_x + 2);
                    triangles.Add(tri_x + 1);
                    triangles.Add(tri_x);

                    triangles.Add(tri_x + 1);
                    triangles.Add(tri_x + 2);
                    triangles.Add(tri_x + 4);
                    triangles.Add(tri_x + 4);
                    triangles.Add(tri_x + 2);
                    triangles.Add(tri_x + 1);

                    triangles.Add(tri_x + 1);
                    triangles.Add(tri_x + 4);
                    triangles.Add(tri_x + 3);
                    triangles.Add(tri_x + 3);
                    triangles.Add(tri_x + 4);
                    triangles.Add(tri_x + 1);

                    triangles.Add(tri_x + 1);
                    triangles.Add(tri_x + 3);
                    triangles.Add(tri_x + 5);
                    triangles.Add(tri_x + 5);
                    triangles.Add(tri_x + 3);
                    triangles.Add(tri_x + 1);

                    triangles.Add(tri_x + 2);
                    triangles.Add(tri_x + 4);
                    triangles.Add(tri_x + 6);
                    triangles.Add(tri_x + 6);
                    triangles.Add(tri_x + 4);
                    triangles.Add(tri_x + 2);

                    //If the height to the next tile is the same, we only need 2 duplicated triangles.
                    if (next_tile.height == temp_tile.height)
                    {
                        if (delta_x < 0)
                        {
                            triangles.Add(tri_x + 3);
                            triangles.Add(tri_x + 4);
                            triangles.Add(tri_x + 7);
                            triangles.Add(tri_x + 7);
                            triangles.Add(tri_x + 4);
                            triangles.Add(tri_x + 3);

                            triangles.Add(tri_x + 9);
                            triangles.Add(tri_x + 7);
                            triangles.Add(tri_x + 4);
                            triangles.Add(tri_x + 4);
                            triangles.Add(tri_x + 7);
                            triangles.Add(tri_x + 9);
                        }
                        else if (delta_x > 0)
                        {
                            triangles.Add(tri_x + 4);
                            triangles.Add(tri_x + 3);
                            triangles.Add(tri_x + 8);
                            triangles.Add(tri_x + 8);
                            triangles.Add(tri_x + 3);
                            triangles.Add(tri_x + 4);

                            triangles.Add(tri_x + 8);
                            triangles.Add(tri_x + 10);
                            triangles.Add(tri_x + 4);
                            triangles.Add(tri_x + 4);
                            triangles.Add(tri_x + 10);
                            triangles.Add(tri_x + 8);
                        }
                        else if (delta_y < 0)
                        {
                            triangles.Add(tri_x + 4);
                            triangles.Add(tri_x + 3);
                            triangles.Add(tri_x + 7);
                            triangles.Add(tri_x + 7);
                            triangles.Add(tri_x + 3);
                            triangles.Add(tri_x + 4);

                            triangles.Add(tri_x + 8);
                            triangles.Add(tri_x + 7);
                            triangles.Add(tri_x + 4);
                            triangles.Add(tri_x + 4);
                            triangles.Add(tri_x + 7);
                            triangles.Add(tri_x + 8);
                        }
                        else if (delta_y > 0)
                        {
                            triangles.Add(tri_x + 3);
                            triangles.Add(tri_x + 4);
                            triangles.Add(tri_x + 9);
                            triangles.Add(tri_x + 9);
                            triangles.Add(tri_x + 4);
                            triangles.Add(tri_x + 3);

                            triangles.Add(tri_x + 9);
                            triangles.Add(tri_x + 10);
                            triangles.Add(tri_x + 4);
                            triangles.Add(tri_x + 4);
                            triangles.Add(tri_x + 10);
                            triangles.Add(tri_x + 9);
                        }
                    }
                    //If not, we need to create an intermediate vertex and create more triangles.
                    else
                    {
                        //create vertices on top of the tile with the lower elevation.
                        float x_pos = next_tile.transform.position.x;
                        float y_pos = temp_tile.transform.position.y + (-START_Y) + 0.027f + TILE_HEIGHT * temp_tile.height;
                        float z_pos = next_tile.transform.position.z;
                        //When decreasing in height we need to invert the location of the vertices.
                        int invert = 1;
                        if (temp_tile.height < next_tile.height)
                        {
                            x_pos = temp_tile.transform.position.x;
                            y_pos = next_tile.transform.position.y + (-START_Y) + 0.027f + TILE_HEIGHT * next_tile.height;
                            z_pos = temp_tile.transform.position.z;
                            invert = -2;
                        }

                        if (delta_x != 0)
                        {
                            vertices.Add(new Vector3(x_pos + tile_width * width_modifier,
                                        y_pos,
                                        z_pos + tile_width * width_modifier * -delta_x * invert));
                            vertices.Add(new Vector3(x_pos - tile_width * width_modifier,
                                        y_pos,
                                        z_pos + tile_width * width_modifier * -delta_x * invert));
                            uv.Add(new Vector2(1, 1));
                            uv.Add(new Vector2(0, 0));
                        }
                        else if (delta_y != 0)
                        {
                            vertices.Add(new Vector3(x_pos + tile_width * width_modifier * -delta_y * invert,
                                        y_pos,
                                        z_pos + tile_width * width_modifier));
                            vertices.Add(new Vector3(x_pos + tile_width * width_modifier * -delta_y * invert,
                                        y_pos,
                                        z_pos - tile_width * width_modifier));
                            uv.Add(new Vector2(1, 1));
                            uv.Add(new Vector2(0, 0));
                        }


                        //Draw triangles connecting tile and previous tile.
                        //Coordinates of vertices for triangles depends on the change in tile index. 
                        if (delta_x < 0)
                        {
                            triangles.Add(tri_x + 3);
                            triangles.Add(tri_x + 4);
                            triangles.Add(tri_x + 7);
                            triangles.Add(tri_x + 7);
                            triangles.Add(tri_x + 4);
                            triangles.Add(tri_x + 3);

                            triangles.Add(tri_x + 7);
                            triangles.Add(tri_x + 8);
                            triangles.Add(tri_x + 4);
                            triangles.Add(tri_x + 4);
                            triangles.Add(tri_x + 7);
                            triangles.Add(tri_x + 8);

                            triangles.Add(tri_x + 7);
                            triangles.Add(tri_x + 8);
                            triangles.Add(tri_x + 11);
                            triangles.Add(tri_x + 11);
                            triangles.Add(tri_x + 8);
                            triangles.Add(tri_x + 7);

                            triangles.Add(tri_x + 9);
                            triangles.Add(tri_x + 11);
                            triangles.Add(tri_x + 7);
                            triangles.Add(tri_x + 7);
                            triangles.Add(tri_x + 11);
                            triangles.Add(tri_x + 9);
                        }
                        else if (delta_x > 0)
                        {
                            triangles.Add(tri_x + 4);
                            triangles.Add(tri_x + 3);
                            triangles.Add(tri_x + 7);
                            triangles.Add(tri_x + 7);
                            triangles.Add(tri_x + 3);
                            triangles.Add(tri_x + 4);

                            triangles.Add(tri_x + 7);
                            triangles.Add(tri_x + 8);
                            triangles.Add(tri_x + 4);
                            triangles.Add(tri_x + 4);
                            triangles.Add(tri_x + 8);
                            triangles.Add(tri_x + 7);

                            triangles.Add(tri_x + 7);
                            triangles.Add(tri_x + 8);
                            triangles.Add(tri_x + 12);
                            triangles.Add(tri_x + 12);
                            triangles.Add(tri_x + 8);
                            triangles.Add(tri_x + 7);

                            triangles.Add(tri_x + 12);
                            triangles.Add(tri_x + 10);
                            triangles.Add(tri_x + 7);
                            triangles.Add(tri_x + 7);
                            triangles.Add(tri_x + 10);
                            triangles.Add(tri_x + 12);
                        }
                        else if (delta_y < 0)
                        {
                            triangles.Add(tri_x + 3);
                            triangles.Add(tri_x + 4);
                            triangles.Add(tri_x + 7);
                            triangles.Add(tri_x + 7);
                            triangles.Add(tri_x + 4);
                            triangles.Add(tri_x + 3);

                            triangles.Add(tri_x + 7);
                            triangles.Add(tri_x + 8);
                            triangles.Add(tri_x + 4);
                            triangles.Add(tri_x + 4);
                            triangles.Add(tri_x + 8);
                            triangles.Add(tri_x + 7);

                            triangles.Add(tri_x + 7);
                            triangles.Add(tri_x + 8);
                            triangles.Add(tri_x + 9);
                            triangles.Add(tri_x + 9);
                            triangles.Add(tri_x + 8);
                            triangles.Add(tri_x + 7);

                            triangles.Add(tri_x + 9);
                            triangles.Add(tri_x + 10);
                            triangles.Add(tri_x + 8);
                            triangles.Add(tri_x + 8);
                            triangles.Add(tri_x + 10);
                            triangles.Add(tri_x + 9);
                        }
                        else if (delta_y > 0)
                        {
                            triangles.Add(tri_x + 3);
                            triangles.Add(tri_x + 4);
                            triangles.Add(tri_x + 7);
                            triangles.Add(tri_x + 7);
                            triangles.Add(tri_x + 4);
                            triangles.Add(tri_x + 3);

                            triangles.Add(tri_x + 7);
                            triangles.Add(tri_x + 8);
                            triangles.Add(tri_x + 4);
                            triangles.Add(tri_x + 4);
                            triangles.Add(tri_x + 8);
                            triangles.Add(tri_x + 7);

                            triangles.Add(tri_x + 7);
                            triangles.Add(tri_x + 8);
                            triangles.Add(tri_x + 11);
                            triangles.Add(tri_x + 11);
                            triangles.Add(tri_x + 8);
                            triangles.Add(tri_x + 7);

                            triangles.Add(tri_x + 11);
                            triangles.Add(tri_x + 12);
                            triangles.Add(tri_x + 8);
                            triangles.Add(tri_x + 8);
                            triangles.Add(tri_x + 12);
                            triangles.Add(tri_x + 11);
                        }
                    }
                }
                //When not dealing with the first tile.
                else
                {
                    //Add a square of vertices inside each traversed tile.
                    vertices.Add(new Vector3(temp_tile.transform.position.x + tile_width * width_modifier,
                            (temp_tile.transform.position.y + (-START_Y) + 0.027f + TILE_HEIGHT * temp_tile.height),
                            temp_tile.transform.position.z + tile_width * width_modifier));
                    vertices.Add(new Vector3(temp_tile.transform.position.x + tile_width * width_modifier,
                                            (temp_tile.transform.position.y + (-START_Y) + 0.027f + TILE_HEIGHT * temp_tile.height),
                                            temp_tile.transform.position.z - tile_width * width_modifier));
                    vertices.Add(new Vector3(temp_tile.transform.position.x - tile_width * width_modifier,
                                            (temp_tile.transform.position.y + (-START_Y) + 0.027f + TILE_HEIGHT * temp_tile.height),
                                            temp_tile.transform.position.z + tile_width * width_modifier));
                    vertices.Add(new Vector3(temp_tile.transform.position.x - tile_width * width_modifier,
                                            (temp_tile.transform.position.y + (-START_Y) + 0.027f + TILE_HEIGHT * temp_tile.height),
                                            temp_tile.transform.position.z - tile_width * width_modifier));
                    uv.Add(new Vector2(0, 1));
                    uv.Add(new Vector2(1, 1));
                    uv.Add(new Vector2(0, 0));
                    uv.Add(new Vector2(1, 0));

                    //Draw triangles for the center square.
                    triangles.Add(tri_x);
                    triangles.Add(tri_x + 1);
                    triangles.Add(tri_x + 2);
                    triangles.Add(tri_x + 2);
                    triangles.Add(tri_x + 1);
                    triangles.Add(tri_x + 3);

                    //Attach new tile's vertices to rest of mesh with new triangles.
                    //If there is no difference in height we can go in a straight line and only need 2 triangles.
                    if (next_tile.height == temp_tile.height)
                    {
                        if (delta_x < 0)
                        {
                            triangles.Add(tri_x + 1);
                            triangles.Add(tri_x + 4);
                            triangles.Add(tri_x + 3);
                            triangles.Add(tri_x + 3);
                            triangles.Add(tri_x + 4);
                            triangles.Add(tri_x + 6);
                        }
                        else if (delta_x > 0)
                        {
                            triangles.Add(tri_x);
                            triangles.Add(tri_x + 2);
                            triangles.Add(tri_x + 5);
                            triangles.Add(tri_x + 2);
                            triangles.Add(tri_x + 7);
                            triangles.Add(tri_x + 5);
                        }
                        else if (delta_y < 0)
                        {
                            triangles.Add(tri_x + 2);
                            triangles.Add(tri_x + 5);
                            triangles.Add(tri_x + 4);
                            triangles.Add(tri_x + 2);
                            triangles.Add(tri_x + 3);
                            triangles.Add(tri_x + 5);
                        }
                        else if (delta_y > 0)
                        {
                            triangles.Add(tri_x + 1);
                            triangles.Add(tri_x);
                            triangles.Add(tri_x + 7);
                            triangles.Add(tri_x);
                            triangles.Add(tri_x + 6);
                            triangles.Add(tri_x + 7);
                        }

                    }//Otherwise, we need new vertices and more triangles.
                    else
                    {
                        //Create vertices on top of tile with lower elevation.
                        float x_pos = next_tile.transform.position.x;
                        float y_pos = temp_tile.transform.position.y + (-START_Y) + 0.027f + TILE_HEIGHT * temp_tile.height;
                        float z_pos = next_tile.transform.position.z;
                        //When decreasing tile height we need to invert the vertex positions.
                        int invert = 1;
                        if (temp_tile.height < next_tile.height)
                        {
                            x_pos = temp_tile.transform.position.x;
                            y_pos = next_tile.transform.position.y + 0.027f + TILE_HEIGHT * next_tile.height;
                            z_pos = temp_tile.transform.position.z;
                            invert = -1;
                        }

                        if (delta_x != 0)
                        {
                            vertices.Add(new Vector3(x_pos + tile_width * width_modifier,
                                        y_pos,
                                        z_pos + tile_width * width_modifier * -delta_x * invert));
                            vertices.Add(new Vector3(x_pos - tile_width * width_modifier,
                                        y_pos,
                                        z_pos + tile_width * width_modifier * -delta_x * invert));
                            uv.Add(new Vector2(1, 1));
                            uv.Add(new Vector2(0, 0));
                        }
                        else if (delta_y != 0)
                        {
                            vertices.Add(new Vector3(x_pos + tile_width * width_modifier * -delta_y * invert,
                                        y_pos,
                                        z_pos + tile_width * width_modifier));
                            vertices.Add(new Vector3(x_pos + tile_width * width_modifier * -delta_y * invert,
                                        y_pos,
                                        z_pos - tile_width * width_modifier));
                            uv.Add(new Vector2(1, 1));
                            uv.Add(new Vector2(0, 0));
                        }


                        //Draw triangles between new vertices.
                        //Triangle coordiantes depend on the change in tile index
                        if (delta_x < 0)
                        {
                            triangles.Add(tri_x + 3);
                            triangles.Add(tri_x + 1);
                            triangles.Add(tri_x + 4);
                            triangles.Add(tri_x + 4);
                            triangles.Add(tri_x + 5);
                            triangles.Add(tri_x + 3);

                            triangles.Add(tri_x + 4);
                            triangles.Add(tri_x + 1);
                            triangles.Add(tri_x + 3);
                            triangles.Add(tri_x + 3);
                            triangles.Add(tri_x + 5);
                            triangles.Add(tri_x + 4);

                            triangles.Add(tri_x + 4);
                            triangles.Add(tri_x + 5);
                            triangles.Add(tri_x + 8);
                            triangles.Add(tri_x + 8);
                            triangles.Add(tri_x + 6);
                            triangles.Add(tri_x + 4);

                            triangles.Add(tri_x + 8);
                            triangles.Add(tri_x + 5);
                            triangles.Add(tri_x + 4);
                            triangles.Add(tri_x + 4);
                            triangles.Add(tri_x + 6);
                            triangles.Add(tri_x + 8);

                        }
                        else if (delta_x > 0)
                        {
                            triangles.Add(tri_x + 2);
                            triangles.Add(tri_x);
                            triangles.Add(tri_x + 4);
                            triangles.Add(tri_x + 4);
                            triangles.Add(tri_x + 5);
                            triangles.Add(tri_x + 2);

                            triangles.Add(tri_x + 4);
                            triangles.Add(tri_x);
                            triangles.Add(tri_x + 2);
                            triangles.Add(tri_x + 2);
                            triangles.Add(tri_x + 5);
                            triangles.Add(tri_x + 4);

                            triangles.Add(tri_x + 5);
                            triangles.Add(tri_x + 4);
                            triangles.Add(tri_x + 7);
                            triangles.Add(tri_x + 7);
                            triangles.Add(tri_x + 9);
                            triangles.Add(tri_x + 5);

                            triangles.Add(tri_x + 7);
                            triangles.Add(tri_x + 4);
                            triangles.Add(tri_x + 5);
                            triangles.Add(tri_x + 5);
                            triangles.Add(tri_x + 9);
                            triangles.Add(tri_x + 7);

                        }
                        else if (delta_y < 0)
                        {
                            triangles.Add(tri_x + 1);
                            triangles.Add(tri_x);
                            triangles.Add(tri_x + 4);
                            triangles.Add(tri_x + 4);
                            triangles.Add(tri_x + 5);
                            triangles.Add(tri_x + 1);

                            triangles.Add(tri_x + 4);
                            triangles.Add(tri_x);
                            triangles.Add(tri_x + 1);
                            triangles.Add(tri_x + 1);
                            triangles.Add(tri_x + 5);
                            triangles.Add(tri_x + 4);

                            triangles.Add(tri_x + 4);
                            triangles.Add(tri_x + 5);
                            triangles.Add(tri_x + 7);
                            triangles.Add(tri_x + 7);
                            triangles.Add(tri_x + 6);
                            triangles.Add(tri_x + 4);

                            triangles.Add(tri_x + 7);
                            triangles.Add(tri_x + 5);
                            triangles.Add(tri_x + 4);
                            triangles.Add(tri_x + 4);
                            triangles.Add(tri_x + 6);
                            triangles.Add(tri_x + 7);

                        }
                        else if (delta_y > 0)
                        {
                            triangles.Add(tri_x + 0);
                            triangles.Add(tri_x + 1);
                            triangles.Add(tri_x + 5);
                            triangles.Add(tri_x + 5);
                            triangles.Add(tri_x + 4);
                            triangles.Add(tri_x + 0);

                            triangles.Add(tri_x + 5);
                            triangles.Add(tri_x + 1);
                            triangles.Add(tri_x + 0);
                            triangles.Add(tri_x + 0);
                            triangles.Add(tri_x + 4);
                            triangles.Add(tri_x + 5);

                            triangles.Add(tri_x + 4);
                            triangles.Add(tri_x + 5);
                            triangles.Add(tri_x + 9);
                            triangles.Add(tri_x + 9);
                            triangles.Add(tri_x + 8);
                            triangles.Add(tri_x + 4);

                            triangles.Add(tri_x + 9);
                            triangles.Add(tri_x + 5);
                            triangles.Add(tri_x + 4);
                            triangles.Add(tri_x + 4);
                            triangles.Add(tri_x + 8);
                            triangles.Add(tri_x + 9);

                        }
                    }
                }
                //Set the current index for the triangle "array" to match the current number of vertices.
                //Don't want to connect to vertices already connected to
                tri_x = vertices.Count;

                //Move to the next tile in the path.
                temp_tile = next_tile;
            }
            //Add 4 vertices on the character's current tile.
            vertices.Add(new Vector3(temp_tile.transform.position.x + tile_width * width_modifier,
                                    (temp_tile.transform.position.y + (-START_Y) + 0.027f + TILE_HEIGHT * temp_tile.height),
                                    temp_tile.transform.position.z + tile_width * width_modifier));
            vertices.Add(new Vector3(temp_tile.transform.position.x + tile_width * width_modifier,
                                    (temp_tile.transform.position.y + (-START_Y) + 0.027f + TILE_HEIGHT * temp_tile.height),
                                    temp_tile.transform.position.z - tile_width * width_modifier));
            vertices.Add(new Vector3(temp_tile.transform.position.x - tile_width * width_modifier,
                                    (temp_tile.transform.position.y + (-START_Y) + 0.027f + TILE_HEIGHT * temp_tile.height),
                                    temp_tile.transform.position.z + tile_width * width_modifier));
            vertices.Add(new Vector3(temp_tile.transform.position.x - tile_width * width_modifier,
                                    (temp_tile.transform.position.y + (-START_Y) + 0.027f + TILE_HEIGHT * temp_tile.height),
                                    temp_tile.transform.position.z - tile_width * width_modifier));
            uv.Add(new Vector2(0, 1));
            uv.Add(new Vector2(1, 1));
            uv.Add(new Vector2(0, 0));
            uv.Add(new Vector2(1, 0));

            //Debug.Log("vertices " + vertices.Count);
            //Debug.Log("uv " + uv.Count);
            //Set the mesh vertices, uv and triangles to match what we calculated.
            mesh.vertices = vertices.ToArray();
            mesh.uv = uv.ToArray();
            mesh.triangles = triangles.ToArray();

            //Draw the mesh using the Scenario object's Mesh Renderer.
            scenario.GetComponent<MeshFilter>().mesh = mesh;

        }
        else
        {
            //IF we have no path to follow the eliminate the current mesh.
            scenario.GetComponent<MeshFilter>().mesh = null;
        }
    }

    /// <summary>
    /// Ran before a Start Method. Ensures there is only ever one Scenario.
    /// </summary>
    void Awake()
    {
        if (scenario == null)
        {
            //DontDestroyOnLoad(gameObject);
            scenario = this;
        }
        else if (scenario != this)
        {
            Destroy(gameObject);
        }
    }

    /// <summary>
    /// Start a scerio from a given scenario file
    /// </summary>
    /*public void Start(string filename)
    {
        scenario_file = filename;
        //Initialize Lists
        rewards = new List<string>();
        bonus_rewards = new List<string>();
        List<int> unlocks_scenarios = new List<int>();
        List<int> unlocks_scenarios_on_loss = new List<int>();
        List<int> unlocks_scenarios_on_win = new List<int>();
        List<int> unlocks_scenarios_on_bonus = new List<int>();
        //Read in the file
        string[] lines = System.IO.File.ReadAllLines(scenario_file);
        string line = "";
        string[] elements = new string[2];
        //30 is the default grid size;
        int grid_width = 30;
        int grid_length = 30;
        Material[] materials = new Material[10];
        double[] tile_modifiers = new double[10];
        int[,] tile_mat_ids = new int[grid_width, grid_length];
        int[,] object_sprite_ids = new int[grid_width, grid_length];
        int[,] character_ids = new int[grid_width, grid_length];
        //Read through the file line by line, looking for specific headings
        for (int i = 0; i < lines.Length; i++)
        {
            line = lines[i];
            switch (line)
            {
                //ID of the scenario
                case "[ID]":
                    scenario_name = lines[i + 1];
                    i += 2;
                    break;
                //What Sector the scenario can be found in
                case "[Sector]":
                    scenario_sector = lines[i + 1];
                    i += 2;
                    break;
                //Name of the Scenario
                case "[Name]":
                    scenario_name = lines[i + 1];
                    i += 2;
                    break;
                //Description for the Scenario
                case "[Description]":
                    description = lines[i + 1];
                    i += 2;
                    break;
                //Objective for the scenario (see Objectives enum for list of possible objectives.)
                case "[Objective]":
                    foreach (Scenario_Objectives obj in System.Enum.GetValues(typeof(Scenario_Objectives)))
                    {
                        if (obj.ToString() == lines[i + 1])
                        {
                            objective = obj;
                        }
                    }
                    i += 2;
                    break;
                //Reward for winning the scenario
                case "[Reward]":
                    for (int j = i + 1; j < lines.Length; j++)
                    {
                        if (lines[j] != "")
                        {
                            rewards.Add(lines[j]);
                        }
                        else
                        {
                            i = j;
                            j = lines.Length;
                        }
                    }
                    break;
                //Bonus objective for the scenario
                case "[Bonus Objective]":
                    bonus_objective = lines[i + 1];
                    i += 2;
                    break;
                //Reward for completing the Bonus Objective
                case "[Bonus Reward]":
                    for (int j = i + 1; j < lines.Length; j++)
                    {
                        if (lines[j] != "")
                        {
                            bonus_rewards.Add(lines[j]);
                        }
                        else
                        {
                            i = j;
                            j = lines.Length;
                        }
                    }
                    break;
                //Scenario IDs that will be unlocked regardless of wether or not the Objective is met
                case "[Unlocks]":
                    elements = lines[i + 1].Split(';');
                    int id = scenario_id;
                    foreach (string s in elements)
                    {
                        if (int.TryParse(s, out id))
                        {
                            unlocks_scenarios.Add(id);
                        }
                    }
                    i += 2;
                    break;
                //Scenario IDs that will be unlocked if the Objective is not met
                case "[Unlocks on Loss]":
                    elements = lines[i + 1].Split(';');
                    id = scenario_id;
                    foreach (string s in elements)
                    {
                        if (int.TryParse(s, out id))
                        {
                            unlocks_scenarios_on_loss.Add(id);
                        }
                    }
                    i += 2;
                    break;
                //Scenario IDs that will be unlocked if the Objective is met
                case "[Unlocks on Win]":
                    elements = lines[i + 1].Split(';');
                    id = scenario_id;
                    foreach (string s in elements)
                    {
                        if (int.TryParse(s, out id))
                        {
                            unlocks_scenarios_on_win.Add(id);
                        }
                    }
                    i += 2;
                    break;
                //Scenario IDs that will be unlocked if the Bonus Objective is met
                case "[Unlocks on Bonus]":
                    elements = lines[i + 1].Split(';');
                    id = scenario_id;
                    foreach (string s in elements)
                    {
                        if (int.TryParse(s, out id))
                        {
                            unlocks_scenarios_on_bonus.Add(id);
                        }
                    }
                    i += 2;
                    break;
                //Size of the tile grid map
                case "[Grid Size]":
                    int width = 30;
                    int length = 30;
                    if (int.TryParse(lines[i + 1].Split(';')[0], out width))
                    {
                        grid_width = width;
                    }
                    if (int.TryParse(lines[i + 1].Split(';')[1], out length))
                    {
                        grid_length = length;
                    }
                    i += 2;
                    break;
                case "[Tiles]":
                    //build materials
                    materials = new Material[10];
                    for (int j = i + 1; j < i + 10 + 1; j++)
                    {
                        string[] entries = lines[j].Split(' ');
                        materials[(j - i - 1)] = (Material)Resources.Load(TILE_MATS + "TileMat0" + (j - i - 1));
                        materials[(j - i - 1)].name = entries[1];
                        materials[(j - i - 1)].mainTexture = (Texture)Resources.Load("Textures/" + entries[1]);
                        double modifier;
                        if (double.TryParse(entries[2], out modifier))
                        {
                            tile_modifiers[j - i - 1] = modifier;
                        }
                    }

                    break;
                case "[Tile Map]":
                    tile_mat_ids = new int[grid_width, grid_length];
                    for (int k = i + 1; k < i + grid_length + 1; k++)
                    {
                        string[] entries = lines[k].Split(';');
                        for (int l = 0; l < grid_width; l++)
                        {
                            int sprite;
                            if (int.TryParse(entries[l], out sprite))
                            {
                                tile_mat_ids[k - i - 1, l] = sprite;
                            }
                        }
                    }
                    break;
                case "[Object Map]":
                    object_sprite_ids = new int[grid_width, grid_length];
                    for (int k = i + 1; k < i + grid_length + 1; k++)
                    {
                        string[] entries = lines[k].Split(';');
                        for (int l = 0; l < grid_width; l++)
                        {
                            int sprite;
                            if (int.TryParse(entries[l], out sprite))
                            {
                                object_sprite_ids[k - i - 1, l] = sprite;
                            }
                        }
                    }
                    break;
                case "[Character Map]":
                    character_ids = new int[grid_width, grid_length];
                    for (int k = i + 1; k < i + grid_length + 1; k++)
                    {
                        string[] entries = lines[k].Split(';');
                        for (int l = 0; l < grid_width; l++)
                        {
                            int sprite;
                            if (int.TryParse(entries[l], out sprite))
                            {
                                character_ids[k - i - 1, l] = sprite;
                            }
                        }
                    }
                    break;
                //Default in case none of the above cases are met
                default:
                    break;
            }
            //Resume new scenario creation
            tile_grid = this.transform.GetChild(0).GetComponent<Tile_Grid>();
            tile_grid.Start(grid_width, grid_length, materials, tile_modifiers, tile_mat_ids, object_sprite_ids, character_ids);

            curr_round = 0;
            curr_character_num = 0;
            turn_order = new List<GameObject>();
            reachable_tiles = new List<Tile>();
            reachable_tile_objects = new List<GameObject>();
            tile_objects = new List<GameObject>();
        }
    }
    */

    /// <summary>
    /// Check to see if the current Character stack has a character in it.
    /// </summary>
    /// <returns>True if a character exists in the stack, false otherwise.</returns>
    public bool Has_Current_Character()
    {
        if (curr_character != null &&
            curr_character.Count > 0)
        {
            //Debug.Log("There is a current character");
            return true;
        }
        return false;
    }

    /// <summary>
    /// Called once per frame to:
    ///     Check for victory.
    ///     Update all Characters.
    ///     Delete Objects that need to be removed.
    /// </summary>
    public void Update () {
        if (SceneManager.GetActiveScene().name != "Editor")
        {
            if (Game_Controller.Get_Curr_Scenario() != null &&
                scenario_id == Game_Controller.Get_Curr_Scenario().scenario_id)
            {
                //if we are on this scenario and the current player has been assigned (scenario is active)
                if (curr_character.Peek() != null)
                {
                    Check_For_Victory();
                }

                //update all characters
                foreach (GameObject character in characters.Values)
                {
                    character.GetComponent<Character_Script>().Update();
                    if (character.GetComponent<Character_Script>().state.Peek() == Character_States.Dead)
                    {
                        character.tag = "Delete";
                    }
                }

                //Remove Tile Objects that hae to be deleted.
                GameObject[] objects = GameObject.FindGameObjectsWithTag("Delete");
                for (int i = 0; i < objects.Length; i++)
                {
                    if (objects[i].GetComponent<Hazard>())
                    {
                        hazards.Remove(objects[i].GetComponent<Hazard>().Get_Scenario_ID());
                    }
                    Destroy(objects[i]);
                }

                /*foreach (GameObject obj in tile_objects)
                {
                    obj.GetComponent<Object_Script>().Update();
                }*/
            }
        }
    }

    /// <summary>
    /// Function to find all tiles within a certain distance and/or travel cost to the current player. 
    /// Adds tiles to the reachable_tiles List if they are reachable. 
    /// </summary>
    /// <param name="chara">The character from which to start the search. </param>
    /// <param name="cost_limit">The limit in cost for traversal. </param>
    /// <param name="distance_limit">The limit in distance (number of tiles away) for traversal. </param>
    /// <param name="type">The type of search. 1 for movement path, 2 for uninterrupted movement , 3 attack range, 4 for attack range with obstacles. </param>
    public List<Tile> Find_Reachable(Character_Script chara, float cost_limit, int distance_limit, int type, bool update)
    {
        //Debug.Log("cost limit: " + cost_limit + "; distance limit: " + distance_limit);
        //Debug.Log(curr_character.Peek().GetComponent<Character_Script>().curr_tile);
        List<Tile> tmp_tiles = new List<Tile>();
        Tile last_Tile = chara.curr_tile;
        //Debug.Log("Character: " + chara.name + " current tile " + last_Tile.name);
        if (chara.Get_Curr_Action() != null && chara.Get_Curr_Actions().Count > 0)
        {
            //Debug.Log("Finding tiles");
            if (chara.Get_Curr_Action().path_type == Path_Types.Path &&
                chara.Get_Curr_Action().curr_path != null &&
                chara.Get_Curr_Action().curr_path.Count - 1 > 0 && 
                chara.Get_Curr_Action().curr_path[chara.Get_Curr_Action().curr_path.Count - 1])
            {
                //Debug.Log("Current Character " + chara.name);
                //Debug.Log("BFS");
                //Debug.Log("BFS with cost limit " + cost_limit + ", distance limit " + distance_limit);
                //tile_grid.navmesh.bfs(curr_character.Peek().GetComponent<Character_Script>().curr_tile, cost_limit, distance_limit);

                //TODO find a better way to do this so we don't change tile settings each time.
                Breadth_First_Search(chara.Get_Curr_Action().curr_path[chara.Get_Curr_Action().curr_path.Count - 1], chara.tag, cost_limit, distance_limit);

                last_Tile = chara.Get_Curr_Action().curr_path[chara.Get_Curr_Action().curr_path.Count - 1];
            }
            else
            {
                Breadth_First_Search(last_Tile, chara.tag, cost_limit, distance_limit);
            }
        }
        else
        {
            Breadth_First_Search(last_Tile, chara.tag, cost_limit, distance_limit);
        }
        int x_index = last_Tile.index[0];
        int y_index = last_Tile.index[1];
        //Debug.Log("["+x_index+","+y_index+"]");
        int i = -distance_limit;
        int j = -distance_limit;
        while (i <= distance_limit)
        {
            while (j <= distance_limit)
            {
                if (x_index + i >= 0 && x_index + i < tiles.GetLength(0))
                {
                    if (y_index + j >= 0 && y_index + j < tiles.GetLength(1))
                    {
                        int h = tiles[x_index + i, y_index + j].height - 1;
                        if (type == 1)
                        {
                            //if (grid.GetComponent<Scenario>().tiles[x_index + i, y_index + j).traversible){
                            //    if ((Math.Abs(x_index - (x_index + i)) * (int)(armor.weight + weapon.weight) + Math.Abs(y_index - (y_index + j)) * (int)(armor.weight + weapon.weight) + (grid.GetComponent<Scenario>().tiles[x_index + i, y_index + j).tile_height - curr_tile.tile_height) * 2) < action_curr)
                            //    {
                            //        reachable_tiles.Add(grid.GetComponent<Scenario>().tiles[x_index + i, y_index + j));
                            //    }
                            //}
                            //Debug.Log("tile weight: " + tiles[x_index + i, y_index + j).weight + " cost_limit: " + cost_limit);
                            //Debug.Log("tile_distance: " + tiles[x_index + i, y_index + j).distance + " distance_limit: " + distance_limit);
                            if (tiles[x_index + i, y_index + j].weight <= cost_limit &&
                                tiles[x_index + i, y_index + j].weight >= 0 &&
                                tiles[x_index + i, y_index + j].distance <= distance_limit)
                            {

                                tmp_tiles.Add(tiles[x_index + i, y_index + j]);
                                //reachable_tiles.Add(new Tile(tiles[x_index + i, y_index + j)));
                                //tiles[x_index + i, y_index + j).weight = -1;
                                //tiles[x_index + i, y_index + j).parent = null;
                            }
                        }
                        if (type == 2)
                        {
                            if (tiles[x_index + i, y_index + j].traversible)
                            {
                                if ((Math.Abs(x_index - (x_index + i)) + Math.Abs(y_index - (y_index + j))) < cost_limit)
                                {
                                    tmp_tiles.Add(tiles[x_index + i, y_index + j]);
                                    //reachable_tiles.Add(new Tile(tiles[x_index + i, y_index + j)));
                                    //tiles[x_index + i, y_index + j).weight = -1;
                                    //tiles[x_index + i, y_index + j).parent = null;
                                }
                            }
                        }
                        if (type == 3)
                        {
                            //print ("scanned x index: " + x_index + i )
                            //Prevent Self-Harm
                            if (i != 0 || j != 0)
                            {
                                if (Math.Abs(i) + Math.Abs(j) <= distance_limit)
                                {
                                    tmp_tiles.Add(tiles[x_index + i, y_index + j]);
                                    //Debug.Log("x index: " + x_index + "; i: " + i);
                                    //Debug.Log("y index: " + y_index + "; j: " + j);
                                    //Debug.Log("Added " + tiles[x_index + i, y_index + j));
                                    //reachable_tiles.Add(new Tile(tiles[x_index + i, y_index + j)));
                                    //tiles[x_index + i, y_index + j).weight = -1;
                                    //tiles[x_index + i, y_index + j).parent = null;
                                }
                            }
                        }
                    }
                }
                j += 1;
            }
            j = -distance_limit;
            i += 1;
        }

        if (update)
        {
            reachable_tiles = tmp_tiles;
        }
        return tmp_tiles;
    }

    public List<Tile> Find_Reachable(Character_Script chara, int direction, float cost_limit, int distance_limit, int type, bool update)
    {
        List<Tile> tiles = new List<Tile>();
        Tile start = chara.curr_tile;
        Tile end = chara.curr_tile;
        if (direction > 3)
        {
            direction = direction % 4;
        }
        if (direction >= 0)
        {
            tiles = Directional_Search(start, direction, cost_limit, distance_limit,null);
            end = tiles[tiles.Count-1];
            //Debug.Log("End: " + end.index[0] + "," + end.index[1]);
            //Stack<Tile> path = tile_grid.navmesh.FindPath(start, end);
        }
        return tiles;
    }

    /// <summary>
    /// Empties the reachable_tiles array. Used when a character changes Action or their turn ends.
    /// </summary>
    public void Reset_Reachable()
    {
        //Debug.Log("Resetting");
        foreach (Tile t in reachable_tiles)
        {
            t.Reset_Reachable();
        }
        reachable_tiles = new List<Tile>();
        Clean_Reachable();
    }

    /// <summary>
    /// Marks all Tiles in the reachable_tiles array with a reachable_tile_prefab object to show that it can be reached by the current Action.
    /// </summary>
    public void Mark_Reachable()
    {
        //Debug.Log("Marking " + reachable_tiles.Count + " Tiles");
        if (curr_character != null &&
            curr_character.Peek() != null)
        {
            reachable_tile_objects = new List<GameObject>();
            //Debug.Log("reachable tile count " + curr_character.Peek().GetComponent<Character_Script>().Get_Curr_Action().reachable_tiles.Count);
            foreach (Tile tile in reachable_tiles)
            {

                //tile_grid.reachable_prefab.GetComponent<SpriteRenderer>().sortingOrder = tile.GetComponent<SpriteRenderer>().sortingOrder;
                if (curr_character.Peek().GetComponent<Character_Script>().state.Peek() == Character_States.Moving || 
                    curr_character.Peek().GetComponent<Character_Script>().state.Peek() == Character_States.Blinking)
                {
                    //Set Material to blue
                    //Debug.Log(tile_grid.reachable_prefab.GetComponent<Material>().name);

                    reachable_prefab.GetComponent<Renderer>().sharedMaterial.color = new Color(0, 255, 255);
                }
                if (curr_character.Peek().GetComponent<Character_Script>().state.Peek() == Character_States.Attacking)
                {
                    //set material to red.
                    //tile_grid.reachable_prefab.GetComponent<Renderer>().sharedMaterial.color = new Color(0, 255, 0);
                }
                GameObject obj = (GameObject)Instantiate(reachable_prefab, new Vector3(tile.transform.position.x,
                                                               //tile.position.y+0.08f,
                                                               //(float)(tile.position.y + (tile.GetComponent<SpriteRenderer>().sprite.rect.height) / 100) - .24f,
                                                               tile.transform.position.y + (-START_Y)+.015f,
                                                               tile.transform.position.z),
                                                               Quaternion.identity);
                //Debug.Log(obj.GetComponent<MeshRenderer>().material.name);
                obj.GetComponent<MeshRenderer>().material = reachable_tile_materials[0];
                //TODO, find a better way to change tile material based on criteria
                if (curr_character.Peek().GetComponent<Character_Script>().Get_Curr_Action().name == "Move" && 
                    (Math.Abs(tile.index[0] - curr_character.Peek().GetComponent<Character_Script>().curr_tile.index[0]) +
                    Math.Abs(tile.index[1] - curr_character.Peek().GetComponent<Character_Script>().curr_tile.index[1]) >
                    curr_character.Peek().GetComponent<Character_Script>().speed) ||
                    tile.weight + curr_character.Peek().GetComponent<Character_Script>().Get_Curr_Action().curr_path_cost > 
                    curr_character.Peek().GetComponent<Character_Script>().speed)
                {
                    obj.GetComponent<MeshRenderer>().material = reachable_tile_materials[1];
                }
                //Set the object Parent to the Scenario Reachable_Tiles
                obj.transform.parent = Game_Controller.Get_Curr_Scenario().transform.GetChild(4);

                reachable_tile_objects.Add(obj);

                //+ tile.GetComponent<SpriteRenderer>().sprite.rect.width/200
                // + selected_tile.GetComponent<SpriteRenderer>().sprite.rect.height/200
            }
        }

    }

    /// <summary>
    /// Removes all reachable_tile_prefab Objects from the board. Removes the effects of MarkReachable().
    /// </summary>
    public void Clean_Reachable()
    {
        //Debug.Log("Cleaning");
        //GameObject[] objects = GameObject.FindGameObjectsWithTag("Reachable");
        foreach (GameObject game_object in reachable_tile_objects)
        {
            //reachable_tile_objects.Remove(game_object);
            Destroy(game_object);
        }
        reachable_tile_objects = new List<GameObject>();
    }

    /// <summary>
    /// Does a Breadth First Search of the Graph and marks the shortest path to all tiles within a given range.
    /// </summary>
    /// <param name="start">The start Tile for the search.</param>
    /// <param name="tag">The the tag to ignore for collision detection.</param>
    /// <param name="cost_limit">The range limit in cost of Edges for how far to look. </param>
    /// <param name="distace_limit">The range limit in distance for how far to look.</param>
    public void Breadth_First_Search(Tile start, string tag, float cost_limit, int distace_limit)
    {
        //reset the previously visited tiles
        Tile n;
        //Debug.Log("visited tiles " + visited_tiles.Count);
        while (visited_tiles.Count != 0)
        {
            n = visited_tiles.Pop();
            n.Reset_Reachable();
        }
        visited_tiles = new Stack<Tile>();
        Queue<Tile> queue = new Queue<Tile>();
        Tile current;
        start.Set_Weight(0);
        start.Set_Distance(0);
        queue.Enqueue(start);
        visited_tiles.Push(start);

        while (queue.Count > 0)
        {
            current = queue.Dequeue();
            //Debug.Log("Current Tile: " + current.index[0] + "," + current.index[1] + "; Cost: " + current.weight);
            foreach (Edge e in current.edges)
            {

                if (e != null)
                {

                    if (e.tile2 != null &&
                        !e.tile2.visited &&
                        current.weight + e.cost <= cost_limit &&
                        //start.obj != null &&
                        (e.tile2.obj == null || e.tile2.obj.tag == tag) &&
                        current.distance < distace_limit)
                    {
                        //Debug.Log("Cost:" + e.cost);
                        e.tile2.Set_Weight(current.weight + e.cost);
                        e.tile2.Set_Distance(current.distance + 1);
                        e.tile2.Set_Visited(true);
                        e.tile2.Set_Parent(current);
                        queue.Enqueue(e.tile2);
                        visited_tiles.Push(e.tile2);
                    }
                    //If the tile has been visited before and 
                    //it is not the starting tile, but 
                    //we found a shorter path to the tile we still update it.
                    if (e.tile2.visited &&
                        e.tile2.index[0] != start.index[0] &&
                        e.tile2.index[1] != start.index[1] &&
                        e.tile2.weight > current.weight + e.cost &&
                        e.tile2.distance < distace_limit)
                    {
                        e.tile2.Set_Weight(current.weight + e.cost);
                        e.tile2.Set_Distance(current.distance + 1);
                        e.tile2.Set_Parent(current);
                        queue.Enqueue(e.tile2);
                    }
                }
            }
        }
    }

    /// <summary>
    /// Searches a specific direction for tiles within a certain distance and cost. 
    /// </summary>
    /// <param name="start">The tile from which to start the search.</param>
    /// <param name="direction">The direction to search in (0-3)</param>
    /// <param name="cost_limit">The cost limit to search.</param>
    /// <param name="distance_limit">The number of tiles away ot search.</param>
    /// <param name="curr_path">The current path to travel.</param>
    public List<Tile> Directional_Search(Tile start, int direction, float cost_limit, int distance_limit, List<Tile> curr_path)
    {
        //reset the previously visited tiles
        Tile n;
        Tile current = start;
        start.Set_Traversible(true);
        start.Set_Obj(null);
        if (curr_path == null)
        {
            //Debug.Log("visited tiles " + visited_tiles.Count);
            while (visited_tiles.Count != 0)
            {
                n = visited_tiles.Pop();
                n.Reset_Reachable();
            }
            visited_tiles = new Stack<Tile>();
            curr_path = new List<Tile>();
            start.Set_Weight(0);
            start.Set_Distance(0);
            visited_tiles.Push(start);
            curr_path.Add(start);
        }
        while (distance_limit > 0)
        {
            Edge e = current.edges[direction];
            //Check we have enough energy to move forward.
            if (e != null &&
                e.cost + current.weight <= cost_limit &&
                (e.tile2.traversible && (e.tile2.obj == null)))
            {
                e.tile2.Set_Weight(current.weight + e.cost);
                e.tile2.Set_Parent(current);
                current = e.tile2;
                if (!visited_tiles.Contains(current))
                {
                    visited_tiles.Push(current);
                }
                curr_path.Add(current);
                distance_limit -= 1;
            }
            else
            {
                return Directional_Search(current, (direction + 2) % 4, cost_limit, distance_limit - 1, curr_path);
            }
        }
        return curr_path;
    }

    public Stack<Tile> Find_Path(Tile start, Tile finish)
    {
        Stack<Tile> path = new Stack<Tile>();
        //If we already have a path from a bfs call.
        //Debug.Log("Start exists " + start.index[0] + "," + start.index[1]);
        //Debug.Log("Finish Exists " + finish.index[0] + "," + finish.index[1]);
        if (visited_tiles.Count != 0)
        {
            Tile temp_tile = finish;
            Tile prev_tile = start;
            //Construct a stack that is a path from the clicked tile to the source.
            while (!(temp_tile.index[0] == start.index[0] && temp_tile.index[1] == start.index[1]))
            {
                path.Push(temp_tile);
                //Look at the parent tile.
                //Debug.Log("parent tile: " + temp_tile.parent.index[0] + "," + temp_tile.parent.index[1]);
                if (temp_tile.parent != null && temp_tile.parent.parent != temp_tile)
                {
                    temp_tile = temp_tile.parent;
                }
                else
                {
                    temp_tile = start;
                    //Debug.Log("PATHING could not find route.");
                }

            }

            //reset the previously visited tiles
            Tile n;
            while (visited_tiles.Count != 0)
            {
                n = visited_tiles.Pop();
                n.Reset_Reachable();
            }

        }
        return path;
    }

    /// <summary>
    /// Move the curr_character to the next available player in the turn_order. Turn_order is sorted in order of Dexterity.
    /// </summary>
    public void Next_Player()
    {
        for (int i = 0; i < characters.Count; i++)
        {
            Character_Script character = ((GameObject)characters[i]).GetComponent<Character_Script>();
            //Debug.Log("Processing " + character.name + " " + character.Get_Char_Num());
            character.Reset_Turn_Stats();
            character.Update_Conditions();
            character.Progress_Conditions();

            if (character.state.Peek() == Character_States.Dead)
            {
                i--;
            }
        }
        /*foreach (GameObject chara in characters) {
            
            chara.GetComponent<Character_Script>().Reset_Combo_Mod();
            //Every turn update the conditions and progress them.
            chara.GetComponent<Character_Script>().Update_Conditions();
            chara.GetComponent<Character_Script>().Progress_Conditions();
        }*/

        Progress_Effects();

        if (curr_character_num % 2 == 0)
        {
            Spawn_Mana_Orb();
            Spawn_Mana_Orb();
        }

        curr_character_num = curr_character_num - 1;
        if (curr_character_num < 0)
        {
            Next_Round();
            curr_character_num = characters.Count - 1;
        }
        if (curr_character_num > characters.Count - 1)
        {
            curr_character_num = characters.Count - 1;
        }
        curr_character.Peek().GetComponent<Animator>().SetBool("Selected", false);
        curr_character.Pop();
        //Debug.Log("Current char num: " + curr_character_num);
        //Debug.Log("Current char name: " + turn_order[curr_character_num].name + " " + turn_order[curr_character_num].GetComponent<Character_Script>().Get_Char_Num());
        curr_character.Push(turn_order[curr_character_num]);
        
        if (curr_character.Peek().GetComponent<Character_Script>().state.Peek() == Character_States.Dead)
        {
            Next_Player();
        }
        else
        {
            curr_character.Peek().GetComponent<Animator>().SetBool("Selected", true);
        }
        //curr_character.Peek().GetComponent<Character_Script>().state = Character_Script.States.Moving;
        //FindReachable(curr_character.Peek().GetComponent<Character_Script>().action_curr, curr_character.Peek().GetComponent<Character_Script>().SPEED);
        Reset_Reachable();

        //Start new player's turn
        curr_character.Peek().GetComponent<Character_Script>().Start_Turn();
    }

    /// <summary>
    /// Move the curr_character.Peek() to the previous available character in the turn_order. Turn_order is sorted in order of Dexterity.
    /// </summary>
    public void Prev_Player()
    {
        foreach (GameObject chara in characters.Values)
        {
            chara.GetComponent<Character_Script>().Reset_Turn_Stats();
            //Every turn update the conditions and progress them.
            chara.GetComponent<Character_Script>().Update_Conditions();
            chara.GetComponent<Character_Script>().Progress_Conditions();
        }

        Progress_Effects();

        if (curr_character_num % 2 == 0)
        {
            Spawn_Mana_Orb();
            Spawn_Mana_Orb();
        }

        curr_character_num = curr_character_num + 1;
        if (curr_character_num >= characters.Count)
        {
            curr_character_num = 0;
        }

        curr_character.Peek().GetComponent<Animator>().SetBool("Selected", false);
        curr_character.Pop();
        curr_character.Push(turn_order[curr_character_num]);
        //Debug.Log("Current character num " + curr_character_num);
        if (curr_character.Peek().GetComponent<Character_Script>().state.Peek() == Character_States.Dead)
        {
            Prev_Player();
        }
        else
        {
            curr_character.Peek().GetComponent<Animator>().SetBool("Selected", true);
        }

        Reset_Reachable();

        //Start the new player's turn
        curr_character.Peek().GetComponent<Character_Script>().Start_Turn();
    }

    /// <summary>
    /// Called at the end of every character Turn to progress the timer on Tile Effects.
    /// </summary>
    public void Progress_Effects()
    {
        if (hazards != null && hazards.Count != 0)
        {
            foreach (GameObject obj in hazards.Values)
            {
                obj.GetComponent<Hazard>().Progress();
            }
        }
    }

    /// <summary>
    /// Used to end the current round and start a new round. 
    /// Increments the curr_round tracker.
    /// </summary>
    public void Next_Round()
    {
        curr_round += 1;
        
    }
}
